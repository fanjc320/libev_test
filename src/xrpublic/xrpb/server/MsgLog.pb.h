// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server/MsgLog.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2fMsgLog_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2fMsgLog_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client/Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2fMsgLog_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2fMsgLog_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2fMsgLog_2eproto;
namespace XrPb {
class ItemLogInfo;
struct ItemLogInfoDefaultTypeInternal;
extern ItemLogInfoDefaultTypeInternal _ItemLogInfo_default_instance_;
class LogRoleBase;
struct LogRoleBaseDefaultTypeInternal;
extern LogRoleBaseDefaultTypeInternal _LogRoleBase_default_instance_;
class MsgSvrMod_Log;
struct MsgSvrMod_LogDefaultTypeInternal;
extern MsgSvrMod_LogDefaultTypeInternal _MsgSvrMod_Log_default_instance_;
class Msg_LOG_BuyGP;
struct Msg_LOG_BuyGPDefaultTypeInternal;
extern Msg_LOG_BuyGPDefaultTypeInternal _Msg_LOG_BuyGP_default_instance_;
class Msg_LOG_BuyMB;
struct Msg_LOG_BuyMBDefaultTypeInternal;
extern Msg_LOG_BuyMBDefaultTypeInternal _Msg_LOG_BuyMB_default_instance_;
class Msg_LOG_GMRecord;
struct Msg_LOG_GMRecordDefaultTypeInternal;
extern Msg_LOG_GMRecordDefaultTypeInternal _Msg_LOG_GMRecord_default_instance_;
class Msg_LOG_RoleAttribute;
struct Msg_LOG_RoleAttributeDefaultTypeInternal;
extern Msg_LOG_RoleAttributeDefaultTypeInternal _Msg_LOG_RoleAttribute_default_instance_;
class Msg_LOG_RoleChatMsg;
struct Msg_LOG_RoleChatMsgDefaultTypeInternal;
extern Msg_LOG_RoleChatMsgDefaultTypeInternal _Msg_LOG_RoleChatMsg_default_instance_;
class Msg_LOG_RoleFriend;
struct Msg_LOG_RoleFriendDefaultTypeInternal;
extern Msg_LOG_RoleFriendDefaultTypeInternal _Msg_LOG_RoleFriend_default_instance_;
class Msg_LOG_RoleItem;
struct Msg_LOG_RoleItemDefaultTypeInternal;
extern Msg_LOG_RoleItemDefaultTypeInternal _Msg_LOG_RoleItem_default_instance_;
class Msg_LOG_RoleLoginLogout;
struct Msg_LOG_RoleLoginLogoutDefaultTypeInternal;
extern Msg_LOG_RoleLoginLogoutDefaultTypeInternal _Msg_LOG_RoleLoginLogout_default_instance_;
class Msg_LOG_RoleProgress;
struct Msg_LOG_RoleProgressDefaultTypeInternal;
extern Msg_LOG_RoleProgressDefaultTypeInternal _Msg_LOG_RoleProgress_default_instance_;
class Msg_Log_CreateRole;
struct Msg_Log_CreateRoleDefaultTypeInternal;
extern Msg_Log_CreateRoleDefaultTypeInternal _Msg_Log_CreateRole_default_instance_;
class Msg_Log_ModifyRoleName;
struct Msg_Log_ModifyRoleNameDefaultTypeInternal;
extern Msg_Log_ModifyRoleNameDefaultTypeInternal _Msg_Log_ModifyRoleName_default_instance_;
class Msg_Log_RecordOnline;
struct Msg_Log_RecordOnlineDefaultTypeInternal;
extern Msg_Log_RecordOnlineDefaultTypeInternal _Msg_Log_RecordOnline_default_instance_;
class Msg_Log_UpLoadFile;
struct Msg_Log_UpLoadFileDefaultTypeInternal;
extern Msg_Log_UpLoadFileDefaultTypeInternal _Msg_Log_UpLoadFile_default_instance_;
}  // namespace XrPb
PROTOBUF_NAMESPACE_OPEN
template<> ::XrPb::ItemLogInfo* Arena::CreateMaybeMessage<::XrPb::ItemLogInfo>(Arena*);
template<> ::XrPb::LogRoleBase* Arena::CreateMaybeMessage<::XrPb::LogRoleBase>(Arena*);
template<> ::XrPb::MsgSvrMod_Log* Arena::CreateMaybeMessage<::XrPb::MsgSvrMod_Log>(Arena*);
template<> ::XrPb::Msg_LOG_BuyGP* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_BuyGP>(Arena*);
template<> ::XrPb::Msg_LOG_BuyMB* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_BuyMB>(Arena*);
template<> ::XrPb::Msg_LOG_GMRecord* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_GMRecord>(Arena*);
template<> ::XrPb::Msg_LOG_RoleAttribute* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleAttribute>(Arena*);
template<> ::XrPb::Msg_LOG_RoleChatMsg* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleChatMsg>(Arena*);
template<> ::XrPb::Msg_LOG_RoleFriend* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleFriend>(Arena*);
template<> ::XrPb::Msg_LOG_RoleItem* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleItem>(Arena*);
template<> ::XrPb::Msg_LOG_RoleLoginLogout* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleLoginLogout>(Arena*);
template<> ::XrPb::Msg_LOG_RoleProgress* Arena::CreateMaybeMessage<::XrPb::Msg_LOG_RoleProgress>(Arena*);
template<> ::XrPb::Msg_Log_CreateRole* Arena::CreateMaybeMessage<::XrPb::Msg_Log_CreateRole>(Arena*);
template<> ::XrPb::Msg_Log_ModifyRoleName* Arena::CreateMaybeMessage<::XrPb::Msg_Log_ModifyRoleName>(Arena*);
template<> ::XrPb::Msg_Log_RecordOnline* Arena::CreateMaybeMessage<::XrPb::Msg_Log_RecordOnline>(Arena*);
template<> ::XrPb::Msg_Log_UpLoadFile* Arena::CreateMaybeMessage<::XrPb::Msg_Log_UpLoadFile>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XrPb {

enum MsgSvrMod_Log_MsgId : int {
  MsgSvrMod_Log_MsgId_Msg_LOG_None = 0,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleLoginLogout = 1,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleItem = 2,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleProgress = 3,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleAttribute = 4,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleFriend = 5,
  MsgSvrMod_Log_MsgId_Msg_Log_RecordOnline = 6,
  MsgSvrMod_Log_MsgId_Msg_LOG_BuyMB = 7,
  MsgSvrMod_Log_MsgId_Msg_LOG_BuyGP = 8,
  MsgSvrMod_Log_MsgId_Msg_Log_CreateRole = 9,
  MsgSvrMod_Log_MsgId_Msg_Log_UpLoadFile = 10,
  MsgSvrMod_Log_MsgId_Msg_Log_ModifyRoleName = 11,
  MsgSvrMod_Log_MsgId_Msg_LOG_RoleChatMsg = 12,
  MsgSvrMod_Log_MsgId_MsgSvrMod_Log_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgSvrMod_Log_MsgId_MsgSvrMod_Log_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgSvrMod_Log_MsgId_IsValid(int value);
constexpr MsgSvrMod_Log_MsgId MsgSvrMod_Log_MsgId_MsgId_MIN = MsgSvrMod_Log_MsgId_Msg_LOG_None;
constexpr MsgSvrMod_Log_MsgId MsgSvrMod_Log_MsgId_MsgId_MAX = MsgSvrMod_Log_MsgId_Msg_LOG_RoleChatMsg;
constexpr int MsgSvrMod_Log_MsgId_MsgId_ARRAYSIZE = MsgSvrMod_Log_MsgId_MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgSvrMod_Log_MsgId_descriptor();
template<typename T>
inline const std::string& MsgSvrMod_Log_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgSvrMod_Log_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgSvrMod_Log_MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgSvrMod_Log_MsgId_descriptor(), enum_t_value);
}
inline bool MsgSvrMod_Log_MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgSvrMod_Log_MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgSvrMod_Log_MsgId>(
    MsgSvrMod_Log_MsgId_descriptor(), name, value);
}
enum EFromType : int {
  eFrom_None = 0,
  eFrom_FirstRecharge = 1,
  eFrom_CreateNewRole = 2,
  eFrom_OnLine = 4,
  eFrom_NewGuide = 5,
  eFrom_Charge = 6,
  eFrom_FinishNewGuide = 7,
  eFrom_GMAdd = 8,
  eFrom_Mail = 9,
  eFrom_MonthSign = 10,
  eFrom_SupplementMonthSign = 11,
  eFrom_MonthSignVip = 12,
  eFrom_LoginSign = 13,
  EFromType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EFromType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EFromType_IsValid(int value);
constexpr EFromType EFromType_MIN = eFrom_None;
constexpr EFromType EFromType_MAX = eFrom_LoginSign;
constexpr int EFromType_ARRAYSIZE = EFromType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EFromType_descriptor();
template<typename T>
inline const std::string& EFromType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EFromType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EFromType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EFromType_descriptor(), enum_t_value);
}
inline bool EFromType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EFromType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EFromType>(
    EFromType_descriptor(), name, value);
}
enum EToType : int {
  eTo_None = 0,
  eTo_WorldChat = 1,
  eTo_GMTake = 2,
  eTo_SupplementSign = 3,
  eTo_IntallPart = 5,
  EToType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EToType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EToType_IsValid(int value);
constexpr EToType EToType_MIN = eTo_None;
constexpr EToType EToType_MAX = eTo_IntallPart;
constexpr int EToType_ARRAYSIZE = EToType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EToType_descriptor();
template<typename T>
inline const std::string& EToType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EToType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EToType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EToType_descriptor(), enum_t_value);
}
inline bool EToType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EToType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EToType>(
    EToType_descriptor(), name, value);
}
enum ELogProgressType : int {
  eLogProgress_None = 0,
  eLogProgress_Guide = 1,
  ELogProgressType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELogProgressType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELogProgressType_IsValid(int value);
constexpr ELogProgressType ELogProgressType_MIN = eLogProgress_None;
constexpr ELogProgressType ELogProgressType_MAX = eLogProgress_Guide;
constexpr int ELogProgressType_ARRAYSIZE = ELogProgressType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogProgressType_descriptor();
template<typename T>
inline const std::string& ELogProgressType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELogProgressType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELogProgressType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELogProgressType_descriptor(), enum_t_value);
}
inline bool ELogProgressType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELogProgressType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELogProgressType>(
    ELogProgressType_descriptor(), name, value);
}
enum ELogAttrType : int {
  eLogAttr_None = 0,
  eLogAttr_RoleLevel = 1,
  ELogAttrType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELogAttrType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELogAttrType_IsValid(int value);
constexpr ELogAttrType ELogAttrType_MIN = eLogAttr_None;
constexpr ELogAttrType ELogAttrType_MAX = eLogAttr_RoleLevel;
constexpr int ELogAttrType_ARRAYSIZE = ELogAttrType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogAttrType_descriptor();
template<typename T>
inline const std::string& ELogAttrType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELogAttrType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELogAttrType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELogAttrType_descriptor(), enum_t_value);
}
inline bool ELogAttrType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELogAttrType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELogAttrType>(
    ELogAttrType_descriptor(), name, value);
}
enum ELogFriendType : int {
  eLogFriend_None = 0,
  eLogFriend_Apply = 1,
  eLogFriend_Add = 2,
  eLogFriend_Delete = 3,
  ELogFriendType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELogFriendType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELogFriendType_IsValid(int value);
constexpr ELogFriendType ELogFriendType_MIN = eLogFriend_None;
constexpr ELogFriendType ELogFriendType_MAX = eLogFriend_Delete;
constexpr int ELogFriendType_ARRAYSIZE = ELogFriendType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogFriendType_descriptor();
template<typename T>
inline const std::string& ELogFriendType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELogFriendType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELogFriendType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELogFriendType_descriptor(), enum_t_value);
}
inline bool ELogFriendType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELogFriendType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELogFriendType>(
    ELogFriendType_descriptor(), name, value);
}
// ===================================================================

class MsgSvrMod_Log final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:XrPb.MsgSvrMod_Log) */ {
 public:
  inline MsgSvrMod_Log() : MsgSvrMod_Log(nullptr) {}
  explicit constexpr MsgSvrMod_Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSvrMod_Log(const MsgSvrMod_Log& from);
  MsgSvrMod_Log(MsgSvrMod_Log&& from) noexcept
    : MsgSvrMod_Log() {
    *this = ::std::move(from);
  }

  inline MsgSvrMod_Log& operator=(const MsgSvrMod_Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSvrMod_Log& operator=(MsgSvrMod_Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSvrMod_Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSvrMod_Log* internal_default_instance() {
    return reinterpret_cast<const MsgSvrMod_Log*>(
               &_MsgSvrMod_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgSvrMod_Log& a, MsgSvrMod_Log& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSvrMod_Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSvrMod_Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSvrMod_Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSvrMod_Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgSvrMod_Log& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgSvrMod_Log& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.MsgSvrMod_Log";
  }
  protected:
  explicit MsgSvrMod_Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MsgSvrMod_Log_MsgId MsgId;
  static constexpr MsgId Msg_LOG_None =
    MsgSvrMod_Log_MsgId_Msg_LOG_None;
  static constexpr MsgId Msg_LOG_RoleLoginLogout =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleLoginLogout;
  static constexpr MsgId Msg_LOG_RoleItem =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleItem;
  static constexpr MsgId Msg_LOG_RoleProgress =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleProgress;
  static constexpr MsgId Msg_LOG_RoleAttribute =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleAttribute;
  static constexpr MsgId Msg_LOG_RoleFriend =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleFriend;
  static constexpr MsgId Msg_Log_RecordOnline =
    MsgSvrMod_Log_MsgId_Msg_Log_RecordOnline;
  static constexpr MsgId Msg_LOG_BuyMB =
    MsgSvrMod_Log_MsgId_Msg_LOG_BuyMB;
  static constexpr MsgId Msg_LOG_BuyGP =
    MsgSvrMod_Log_MsgId_Msg_LOG_BuyGP;
  static constexpr MsgId Msg_Log_CreateRole =
    MsgSvrMod_Log_MsgId_Msg_Log_CreateRole;
  static constexpr MsgId Msg_Log_UpLoadFile =
    MsgSvrMod_Log_MsgId_Msg_Log_UpLoadFile;
  static constexpr MsgId Msg_Log_ModifyRoleName =
    MsgSvrMod_Log_MsgId_Msg_Log_ModifyRoleName;
  static constexpr MsgId Msg_LOG_RoleChatMsg =
    MsgSvrMod_Log_MsgId_Msg_LOG_RoleChatMsg;
  static inline bool MsgId_IsValid(int value) {
    return MsgSvrMod_Log_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    MsgSvrMod_Log_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    MsgSvrMod_Log_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    MsgSvrMod_Log_MsgId_MsgId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgId_descriptor() {
    return MsgSvrMod_Log_MsgId_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return MsgSvrMod_Log_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgId* value) {
    return MsgSvrMod_Log_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:XrPb.MsgSvrMod_Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class LogRoleBase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.LogRoleBase) */ {
 public:
  inline LogRoleBase() : LogRoleBase(nullptr) {}
  ~LogRoleBase() override;
  explicit constexpr LogRoleBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRoleBase(const LogRoleBase& from);
  LogRoleBase(LogRoleBase&& from) noexcept
    : LogRoleBase() {
    *this = ::std::move(from);
  }

  inline LogRoleBase& operator=(const LogRoleBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRoleBase& operator=(LogRoleBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRoleBase& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRoleBase* internal_default_instance() {
    return reinterpret_cast<const LogRoleBase*>(
               &_LogRoleBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogRoleBase& a, LogRoleBase& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRoleBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRoleBase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRoleBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRoleBase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRoleBase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogRoleBase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRoleBase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.LogRoleBase";
  }
  protected:
  explicit LogRoleBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevIdFieldNumber = 5,
    kChannelFieldNumber = 9,
    kRoleNameFieldNumber = 10,
    kClientIpFieldNumber = 11,
    kAccIdFieldNumber = 1,
    kLevelFieldNumber = 2,
    kArenaTypeFieldNumber = 3,
    kArenaLevelFieldNumber = 4,
    kAreannoFieldNumber = 6,
    kTimeFieldNumber = 7,
    kPlatidFieldNumber = 8,
  };
  // optional string dev_id = 5;
  bool has_dev_id() const;
  private:
  bool _internal_has_dev_id() const;
  public:
  void clear_dev_id();
  const std::string& dev_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dev_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dev_id();
  PROTOBUF_NODISCARD std::string* release_dev_id();
  void set_allocated_dev_id(std::string* dev_id);
  private:
  const std::string& _internal_dev_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dev_id(const std::string& value);
  std::string* _internal_mutable_dev_id();
  public:

  // optional string channel = 9;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // optional string role_name = 10;
  bool has_role_name() const;
  private:
  bool _internal_has_role_name() const;
  public:
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // optional string client_ip = 11;
  bool has_client_ip() const;
  private:
  bool _internal_has_client_ip() const;
  public:
  void clear_client_ip();
  const std::string& client_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_ip();
  PROTOBUF_NODISCARD std::string* release_client_ip();
  void set_allocated_client_ip(std::string* client_ip);
  private:
  const std::string& _internal_client_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_ip(const std::string& value);
  std::string* _internal_mutable_client_ip();
  public:

  // int64 acc_id = 1;
  void clear_acc_id();
  int64_t acc_id() const;
  void set_acc_id(int64_t value);
  private:
  int64_t _internal_acc_id() const;
  void _internal_set_acc_id(int64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 arena_type = 3;
  void clear_arena_type();
  uint32_t arena_type() const;
  void set_arena_type(uint32_t value);
  private:
  uint32_t _internal_arena_type() const;
  void _internal_set_arena_type(uint32_t value);
  public:

  // uint32 arena_level = 4;
  void clear_arena_level();
  uint32_t arena_level() const;
  void set_arena_level(uint32_t value);
  private:
  uint32_t _internal_arena_level() const;
  void _internal_set_arena_level(uint32_t value);
  public:

  // optional uint32 areanno = 6;
  bool has_areanno() const;
  private:
  bool _internal_has_areanno() const;
  public:
  void clear_areanno();
  uint32_t areanno() const;
  void set_areanno(uint32_t value);
  private:
  uint32_t _internal_areanno() const;
  void _internal_set_areanno(uint32_t value);
  public:

  // optional int64 time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // optional uint32 platid = 8;
  bool has_platid() const;
  private:
  bool _internal_has_platid() const;
  public:
  void clear_platid();
  uint32_t platid() const;
  void set_platid(uint32_t value);
  private:
  uint32_t _internal_platid() const;
  void _internal_set_platid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.LogRoleBase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dev_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_ip_;
  int64_t acc_id_;
  uint32_t level_;
  uint32_t arena_type_;
  uint32_t arena_level_;
  uint32_t areanno_;
  int64_t time_;
  uint32_t platid_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_Log_UpLoadFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_Log_UpLoadFile) */ {
 public:
  inline Msg_Log_UpLoadFile() : Msg_Log_UpLoadFile(nullptr) {}
  ~Msg_Log_UpLoadFile() override;
  explicit constexpr Msg_Log_UpLoadFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_Log_UpLoadFile(const Msg_Log_UpLoadFile& from);
  Msg_Log_UpLoadFile(Msg_Log_UpLoadFile&& from) noexcept
    : Msg_Log_UpLoadFile() {
    *this = ::std::move(from);
  }

  inline Msg_Log_UpLoadFile& operator=(const Msg_Log_UpLoadFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_Log_UpLoadFile& operator=(Msg_Log_UpLoadFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_Log_UpLoadFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_Log_UpLoadFile* internal_default_instance() {
    return reinterpret_cast<const Msg_Log_UpLoadFile*>(
               &_Msg_Log_UpLoadFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Msg_Log_UpLoadFile& a, Msg_Log_UpLoadFile& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_Log_UpLoadFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_Log_UpLoadFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_Log_UpLoadFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_Log_UpLoadFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_Log_UpLoadFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_Log_UpLoadFile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_Log_UpLoadFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_Log_UpLoadFile";
  }
  protected:
  explicit Msg_Log_UpLoadFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomLogFieldNumber = 3,
    kLogpathFieldNumber = 4,
    kRoomidFieldNumber = 2,
    kAreanoFieldNumber = 1,
    kServeridFieldNumber = 5,
    kSizeFieldNumber = 6,
    kFailresFieldNumber = 7,
  };
  // optional string roomLog = 3;
  bool has_roomlog() const;
  private:
  bool _internal_has_roomlog() const;
  public:
  void clear_roomlog();
  const std::string& roomlog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomlog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomlog();
  PROTOBUF_NODISCARD std::string* release_roomlog();
  void set_allocated_roomlog(std::string* roomlog);
  private:
  const std::string& _internal_roomlog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomlog(const std::string& value);
  std::string* _internal_mutable_roomlog();
  public:

  // optional string logpath = 4;
  bool has_logpath() const;
  private:
  bool _internal_has_logpath() const;
  public:
  void clear_logpath();
  const std::string& logpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logpath();
  PROTOBUF_NODISCARD std::string* release_logpath();
  void set_allocated_logpath(std::string* logpath);
  private:
  const std::string& _internal_logpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logpath(const std::string& value);
  std::string* _internal_mutable_logpath();
  public:

  // optional int64 roomid = 2;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  int64_t roomid() const;
  void set_roomid(int64_t value);
  private:
  int64_t _internal_roomid() const;
  void _internal_set_roomid(int64_t value);
  public:

  // optional uint32 areano = 1;
  bool has_areano() const;
  private:
  bool _internal_has_areano() const;
  public:
  void clear_areano();
  uint32_t areano() const;
  void set_areano(uint32_t value);
  private:
  uint32_t _internal_areano() const;
  void _internal_set_areano(uint32_t value);
  public:

  // optional uint32 serverid = 5;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // optional uint32 size = 6;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional bool failres = 7;
  bool has_failres() const;
  private:
  bool _internal_has_failres() const;
  public:
  void clear_failres();
  bool failres() const;
  void set_failres(bool value);
  private:
  bool _internal_failres() const;
  void _internal_set_failres(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_Log_UpLoadFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomlog_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logpath_;
  int64_t roomid_;
  uint32_t areano_;
  uint32_t serverid_;
  uint32_t size_;
  bool failres_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleLoginLogout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleLoginLogout) */ {
 public:
  inline Msg_LOG_RoleLoginLogout() : Msg_LOG_RoleLoginLogout(nullptr) {}
  ~Msg_LOG_RoleLoginLogout() override;
  explicit constexpr Msg_LOG_RoleLoginLogout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleLoginLogout(const Msg_LOG_RoleLoginLogout& from);
  Msg_LOG_RoleLoginLogout(Msg_LOG_RoleLoginLogout&& from) noexcept
    : Msg_LOG_RoleLoginLogout() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleLoginLogout& operator=(const Msg_LOG_RoleLoginLogout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleLoginLogout& operator=(Msg_LOG_RoleLoginLogout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleLoginLogout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleLoginLogout* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleLoginLogout*>(
               &_Msg_LOG_RoleLoginLogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Msg_LOG_RoleLoginLogout& a, Msg_LOG_RoleLoginLogout& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleLoginLogout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleLoginLogout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleLoginLogout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleLoginLogout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleLoginLogout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleLoginLogout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleLoginLogout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleLoginLogout";
  }
  protected:
  explicit Msg_LOG_RoleLoginLogout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kGameVersionFieldNumber = 8,
    kEnterTimeFieldNumber = 3,
    kInOutFieldNumber = 2,
    kCoinGPFieldNumber = 4,
    kCoinMBFieldNumber = 5,
    kVipFieldNumber = 6,
    kLeaveTimeFieldNumber = 7,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // .XrPb.GameVersion game_version = 8;
  bool has_game_version() const;
  private:
  bool _internal_has_game_version() const;
  public:
  void clear_game_version();
  const ::XrPb::GameVersion& game_version() const;
  PROTOBUF_NODISCARD ::XrPb::GameVersion* release_game_version();
  ::XrPb::GameVersion* mutable_game_version();
  void set_allocated_game_version(::XrPb::GameVersion* game_version);
  private:
  const ::XrPb::GameVersion& _internal_game_version() const;
  ::XrPb::GameVersion* _internal_mutable_game_version();
  public:
  void unsafe_arena_set_allocated_game_version(
      ::XrPb::GameVersion* game_version);
  ::XrPb::GameVersion* unsafe_arena_release_game_version();

  // optional int64 enter_time = 3;
  bool has_enter_time() const;
  private:
  bool _internal_has_enter_time() const;
  public:
  void clear_enter_time();
  int64_t enter_time() const;
  void set_enter_time(int64_t value);
  private:
  int64_t _internal_enter_time() const;
  void _internal_set_enter_time(int64_t value);
  public:

  // optional uint32 in_out = 2;
  bool has_in_out() const;
  private:
  bool _internal_has_in_out() const;
  public:
  void clear_in_out();
  uint32_t in_out() const;
  void set_in_out(uint32_t value);
  private:
  uint32_t _internal_in_out() const;
  void _internal_set_in_out(uint32_t value);
  public:

  // optional uint32 coin_GP = 4;
  bool has_coin_gp() const;
  private:
  bool _internal_has_coin_gp() const;
  public:
  void clear_coin_gp();
  uint32_t coin_gp() const;
  void set_coin_gp(uint32_t value);
  private:
  uint32_t _internal_coin_gp() const;
  void _internal_set_coin_gp(uint32_t value);
  public:

  // optional uint32 coin_MB = 5;
  bool has_coin_mb() const;
  private:
  bool _internal_has_coin_mb() const;
  public:
  void clear_coin_mb();
  uint32_t coin_mb() const;
  void set_coin_mb(uint32_t value);
  private:
  uint32_t _internal_coin_mb() const;
  void _internal_set_coin_mb(uint32_t value);
  public:

  // optional bool vip = 6;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  bool vip() const;
  void set_vip(bool value);
  private:
  bool _internal_vip() const;
  void _internal_set_vip(bool value);
  public:

  // optional int64 leave_time = 7;
  bool has_leave_time() const;
  private:
  bool _internal_has_leave_time() const;
  public:
  void clear_leave_time();
  int64_t leave_time() const;
  void set_leave_time(int64_t value);
  private:
  int64_t _internal_leave_time() const;
  void _internal_set_leave_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleLoginLogout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::LogRoleBase* role_;
  ::XrPb::GameVersion* game_version_;
  int64_t enter_time_;
  uint32_t in_out_;
  uint32_t coin_gp_;
  uint32_t coin_mb_;
  bool vip_;
  int64_t leave_time_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class ItemLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.ItemLogInfo) */ {
 public:
  inline ItemLogInfo() : ItemLogInfo(nullptr) {}
  ~ItemLogInfo() override;
  explicit constexpr ItemLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemLogInfo(const ItemLogInfo& from);
  ItemLogInfo(ItemLogInfo&& from) noexcept
    : ItemLogInfo() {
    *this = ::std::move(from);
  }

  inline ItemLogInfo& operator=(const ItemLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemLogInfo& operator=(ItemLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemLogInfo* internal_default_instance() {
    return reinterpret_cast<const ItemLogInfo*>(
               &_ItemLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ItemLogInfo& a, ItemLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.ItemLogInfo";
  }
  protected:
  explicit ItemLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kNewValFieldNumber = 3,
    kOldValFieldNumber = 4,
    kFromFieldNumber = 5,
    kToFieldNumber = 6,
    kGetIdFieldNumber = 7,
  };
  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional uint32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // optional int32 new_val = 3;
  bool has_new_val() const;
  private:
  bool _internal_has_new_val() const;
  public:
  void clear_new_val();
  int32_t new_val() const;
  void set_new_val(int32_t value);
  private:
  int32_t _internal_new_val() const;
  void _internal_set_new_val(int32_t value);
  public:

  // optional int32 old_val = 4;
  bool has_old_val() const;
  private:
  bool _internal_has_old_val() const;
  public:
  void clear_old_val();
  int32_t old_val() const;
  void set_old_val(int32_t value);
  private:
  int32_t _internal_old_val() const;
  void _internal_set_old_val(int32_t value);
  public:

  // optional .XrPb.EFromType from = 5;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  ::XrPb::EFromType from() const;
  void set_from(::XrPb::EFromType value);
  private:
  ::XrPb::EFromType _internal_from() const;
  void _internal_set_from(::XrPb::EFromType value);
  public:

  // optional .XrPb.EToType to = 6;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  ::XrPb::EToType to() const;
  void set_to(::XrPb::EToType value);
  private:
  ::XrPb::EToType _internal_to() const;
  void _internal_set_to(::XrPb::EToType value);
  public:

  // optional int64 get_id = 7;
  bool has_get_id() const;
  private:
  bool _internal_has_get_id() const;
  public:
  void clear_get_id();
  int64_t get_id() const;
  void set_get_id(int64_t value);
  private:
  int64_t _internal_get_id() const;
  void _internal_set_get_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.ItemLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t type_;
  uint32_t id_;
  int32_t new_val_;
  int32_t old_val_;
  int from_;
  int to_;
  int64_t get_id_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleItem) */ {
 public:
  inline Msg_LOG_RoleItem() : Msg_LOG_RoleItem(nullptr) {}
  ~Msg_LOG_RoleItem() override;
  explicit constexpr Msg_LOG_RoleItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleItem(const Msg_LOG_RoleItem& from);
  Msg_LOG_RoleItem(Msg_LOG_RoleItem&& from) noexcept
    : Msg_LOG_RoleItem() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleItem& operator=(const Msg_LOG_RoleItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleItem& operator=(Msg_LOG_RoleItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleItem* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleItem*>(
               &_Msg_LOG_RoleItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Msg_LOG_RoleItem& a, Msg_LOG_RoleItem& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleItem";
  }
  protected:
  explicit Msg_LOG_RoleItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 2,
    kRoleFieldNumber = 1,
    kItemsFieldNumber = 3,
  };
  // optional string comment = 2;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // .XrPb.ItemLogInfo items = 3;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::XrPb::ItemLogInfo& items() const;
  PROTOBUF_NODISCARD ::XrPb::ItemLogInfo* release_items();
  ::XrPb::ItemLogInfo* mutable_items();
  void set_allocated_items(::XrPb::ItemLogInfo* items);
  private:
  const ::XrPb::ItemLogInfo& _internal_items() const;
  ::XrPb::ItemLogInfo* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::XrPb::ItemLogInfo* items);
  ::XrPb::ItemLogInfo* unsafe_arena_release_items();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  ::XrPb::LogRoleBase* role_;
  ::XrPb::ItemLogInfo* items_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleProgress) */ {
 public:
  inline Msg_LOG_RoleProgress() : Msg_LOG_RoleProgress(nullptr) {}
  ~Msg_LOG_RoleProgress() override;
  explicit constexpr Msg_LOG_RoleProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleProgress(const Msg_LOG_RoleProgress& from);
  Msg_LOG_RoleProgress(Msg_LOG_RoleProgress&& from) noexcept
    : Msg_LOG_RoleProgress() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleProgress& operator=(const Msg_LOG_RoleProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleProgress& operator=(Msg_LOG_RoleProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleProgress* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleProgress*>(
               &_Msg_LOG_RoleProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Msg_LOG_RoleProgress& a, Msg_LOG_RoleProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleProgress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleProgress";
  }
  protected:
  explicit Msg_LOG_RoleProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // .XrPb.ELogProgressType type = 2;
  void clear_type();
  ::XrPb::ELogProgressType type() const;
  void set_type(::XrPb::ELogProgressType value);
  private:
  ::XrPb::ELogProgressType _internal_type() const;
  void _internal_set_type(::XrPb::ELogProgressType value);
  public:

  // optional uint32 progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  uint32_t progress() const;
  void set_progress(uint32_t value);
  private:
  uint32_t _internal_progress() const;
  void _internal_set_progress(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::LogRoleBase* role_;
  int type_;
  uint32_t progress_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleAttribute) */ {
 public:
  inline Msg_LOG_RoleAttribute() : Msg_LOG_RoleAttribute(nullptr) {}
  ~Msg_LOG_RoleAttribute() override;
  explicit constexpr Msg_LOG_RoleAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleAttribute(const Msg_LOG_RoleAttribute& from);
  Msg_LOG_RoleAttribute(Msg_LOG_RoleAttribute&& from) noexcept
    : Msg_LOG_RoleAttribute() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleAttribute& operator=(const Msg_LOG_RoleAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleAttribute& operator=(Msg_LOG_RoleAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleAttribute* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleAttribute*>(
               &_Msg_LOG_RoleAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Msg_LOG_RoleAttribute& a, Msg_LOG_RoleAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleAttribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleAttribute";
  }
  protected:
  explicit Msg_LOG_RoleAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLevelFieldNumber = 3,
    kIdFieldNumber = 4,
    kExpFieldNumber = 5,
    kFromFieldNumber = 6,
    kConfigIdFieldNumber = 7,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // .XrPb.ELogAttrType type = 2;
  void clear_type();
  ::XrPb::ELogAttrType type() const;
  void set_type(::XrPb::ELogAttrType value);
  private:
  ::XrPb::ELogAttrType _internal_type() const;
  void _internal_set_type(::XrPb::ELogAttrType value);
  public:

  // optional uint32 level = 3;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // optional uint32 id = 4;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // optional uint32 exp = 5;
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;
  public:
  void clear_exp();
  uint32_t exp() const;
  void set_exp(uint32_t value);
  private:
  uint32_t _internal_exp() const;
  void _internal_set_exp(uint32_t value);
  public:

  // optional .XrPb.EFromType from = 6;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  ::XrPb::EFromType from() const;
  void set_from(::XrPb::EFromType value);
  private:
  ::XrPb::EFromType _internal_from() const;
  void _internal_set_from(::XrPb::EFromType value);
  public:

  // optional uint32 config_id = 7;
  bool has_config_id() const;
  private:
  bool _internal_has_config_id() const;
  public:
  void clear_config_id();
  uint32_t config_id() const;
  void set_config_id(uint32_t value);
  private:
  uint32_t _internal_config_id() const;
  void _internal_set_config_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::LogRoleBase* role_;
  int type_;
  uint32_t level_;
  uint32_t id_;
  uint32_t exp_;
  int from_;
  uint32_t config_id_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleFriend) */ {
 public:
  inline Msg_LOG_RoleFriend() : Msg_LOG_RoleFriend(nullptr) {}
  ~Msg_LOG_RoleFriend() override;
  explicit constexpr Msg_LOG_RoleFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleFriend(const Msg_LOG_RoleFriend& from);
  Msg_LOG_RoleFriend(Msg_LOG_RoleFriend&& from) noexcept
    : Msg_LOG_RoleFriend() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleFriend& operator=(const Msg_LOG_RoleFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleFriend& operator=(Msg_LOG_RoleFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleFriend* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleFriend*>(
               &_Msg_LOG_RoleFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Msg_LOG_RoleFriend& a, Msg_LOG_RoleFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleFriend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleFriend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleFriend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleFriend";
  }
  protected:
  explicit Msg_LOG_RoleFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kFriendIdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // optional int64 friend_id = 3;
  bool has_friend_id() const;
  private:
  bool _internal_has_friend_id() const;
  public:
  void clear_friend_id();
  int64_t friend_id() const;
  void set_friend_id(int64_t value);
  private:
  int64_t _internal_friend_id() const;
  void _internal_set_friend_id(int64_t value);
  public:

  // .XrPb.ELogFriendType type = 2;
  void clear_type();
  ::XrPb::ELogFriendType type() const;
  void set_type(::XrPb::ELogFriendType value);
  private:
  ::XrPb::ELogFriendType _internal_type() const;
  void _internal_set_type(::XrPb::ELogFriendType value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::LogRoleBase* role_;
  int64_t friend_id_;
  int type_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_GMRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_GMRecord) */ {
 public:
  inline Msg_LOG_GMRecord() : Msg_LOG_GMRecord(nullptr) {}
  ~Msg_LOG_GMRecord() override;
  explicit constexpr Msg_LOG_GMRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_GMRecord(const Msg_LOG_GMRecord& from);
  Msg_LOG_GMRecord(Msg_LOG_GMRecord&& from) noexcept
    : Msg_LOG_GMRecord() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_GMRecord& operator=(const Msg_LOG_GMRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_GMRecord& operator=(Msg_LOG_GMRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_GMRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_GMRecord* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_GMRecord*>(
               &_Msg_LOG_GMRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Msg_LOG_GMRecord& a, Msg_LOG_GMRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_GMRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_GMRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_GMRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_GMRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_GMRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_GMRecord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_GMRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_GMRecord";
  }
  protected:
  explicit Msg_LOG_GMRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGmFieldNumber = 2,
    kRoleFieldNumber = 1,
  };
  // string gm = 2;
  void clear_gm();
  const std::string& gm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gm();
  PROTOBUF_NODISCARD std::string* release_gm();
  void set_allocated_gm(std::string* gm);
  private:
  const std::string& _internal_gm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gm(const std::string& value);
  std::string* _internal_mutable_gm();
  public:

  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_GMRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gm_;
  ::XrPb::LogRoleBase* role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_BuyMB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_BuyMB) */ {
 public:
  inline Msg_LOG_BuyMB() : Msg_LOG_BuyMB(nullptr) {}
  ~Msg_LOG_BuyMB() override;
  explicit constexpr Msg_LOG_BuyMB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_BuyMB(const Msg_LOG_BuyMB& from);
  Msg_LOG_BuyMB(Msg_LOG_BuyMB&& from) noexcept
    : Msg_LOG_BuyMB() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_BuyMB& operator=(const Msg_LOG_BuyMB& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_BuyMB& operator=(Msg_LOG_BuyMB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_BuyMB& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_BuyMB* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_BuyMB*>(
               &_Msg_LOG_BuyMB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Msg_LOG_BuyMB& a, Msg_LOG_BuyMB& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_BuyMB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_BuyMB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_BuyMB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_BuyMB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_BuyMB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_BuyMB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_BuyMB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_BuyMB";
  }
  protected:
  explicit Msg_LOG_BuyMB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kUiChargeFieldNumber = 2,
    kUiTotalFieldNumber = 3,
    kLlOrderNumFieldNumber = 5,
    kUiIdFieldNumber = 4,
    kUiRmbFieldNumber = 6,
    kLlStartFieldNumber = 8,
    kLlEndFieldNumber = 9,
    kUiStatusFieldNumber = 7,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // uint32 uiCharge = 2;
  void clear_uicharge();
  uint32_t uicharge() const;
  void set_uicharge(uint32_t value);
  private:
  uint32_t _internal_uicharge() const;
  void _internal_set_uicharge(uint32_t value);
  public:

  // uint32 uiTotal = 3;
  void clear_uitotal();
  uint32_t uitotal() const;
  void set_uitotal(uint32_t value);
  private:
  uint32_t _internal_uitotal() const;
  void _internal_set_uitotal(uint32_t value);
  public:

  // int64 llOrderNum = 5;
  void clear_llordernum();
  int64_t llordernum() const;
  void set_llordernum(int64_t value);
  private:
  int64_t _internal_llordernum() const;
  void _internal_set_llordernum(int64_t value);
  public:

  // uint32 uiId = 4;
  void clear_uiid();
  uint32_t uiid() const;
  void set_uiid(uint32_t value);
  private:
  uint32_t _internal_uiid() const;
  void _internal_set_uiid(uint32_t value);
  public:

  // uint32 uiRmb = 6;
  void clear_uirmb();
  uint32_t uirmb() const;
  void set_uirmb(uint32_t value);
  private:
  uint32_t _internal_uirmb() const;
  void _internal_set_uirmb(uint32_t value);
  public:

  // optional int64 llStart = 8;
  bool has_llstart() const;
  private:
  bool _internal_has_llstart() const;
  public:
  void clear_llstart();
  int64_t llstart() const;
  void set_llstart(int64_t value);
  private:
  int64_t _internal_llstart() const;
  void _internal_set_llstart(int64_t value);
  public:

  // optional int64 llEnd = 9;
  bool has_llend() const;
  private:
  bool _internal_has_llend() const;
  public:
  void clear_llend();
  int64_t llend() const;
  void set_llend(int64_t value);
  private:
  int64_t _internal_llend() const;
  void _internal_set_llend(int64_t value);
  public:

  // uint32 uiStatus = 7;
  void clear_uistatus();
  uint32_t uistatus() const;
  void set_uistatus(uint32_t value);
  private:
  uint32_t _internal_uistatus() const;
  void _internal_set_uistatus(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_BuyMB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::LogRoleBase* role_;
  uint32_t uicharge_;
  uint32_t uitotal_;
  int64_t llordernum_;
  uint32_t uiid_;
  uint32_t uirmb_;
  int64_t llstart_;
  int64_t llend_;
  uint32_t uistatus_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_BuyGP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_BuyGP) */ {
 public:
  inline Msg_LOG_BuyGP() : Msg_LOG_BuyGP(nullptr) {}
  ~Msg_LOG_BuyGP() override;
  explicit constexpr Msg_LOG_BuyGP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_BuyGP(const Msg_LOG_BuyGP& from);
  Msg_LOG_BuyGP(Msg_LOG_BuyGP&& from) noexcept
    : Msg_LOG_BuyGP() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_BuyGP& operator=(const Msg_LOG_BuyGP& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_BuyGP& operator=(Msg_LOG_BuyGP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_BuyGP& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_BuyGP* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_BuyGP*>(
               &_Msg_LOG_BuyGP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Msg_LOG_BuyGP& a, Msg_LOG_BuyGP& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_BuyGP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_BuyGP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_BuyGP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_BuyGP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_BuyGP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_BuyGP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_BuyGP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_BuyGP";
  }
  protected:
  explicit Msg_LOG_BuyGP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kUiSequenceFieldNumber = 2,
    kUiGpFieldNumber = 3,
    kUiMbFieldNumber = 4,
    kUiCostFieldNumber = 5,
  };
  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // uint32 uiSequence = 2;
  void clear_uisequence();
  uint32_t uisequence() const;
  void set_uisequence(uint32_t value);
  private:
  uint32_t _internal_uisequence() const;
  void _internal_set_uisequence(uint32_t value);
  public:

  // uint32 uiGp = 3;
  void clear_uigp();
  uint32_t uigp() const;
  void set_uigp(uint32_t value);
  private:
  uint32_t _internal_uigp() const;
  void _internal_set_uigp(uint32_t value);
  public:

  // uint32 uiMb = 4;
  void clear_uimb();
  uint32_t uimb() const;
  void set_uimb(uint32_t value);
  private:
  uint32_t _internal_uimb() const;
  void _internal_set_uimb(uint32_t value);
  public:

  // uint32 uiCost = 5;
  void clear_uicost();
  uint32_t uicost() const;
  void set_uicost(uint32_t value);
  private:
  uint32_t _internal_uicost() const;
  void _internal_set_uicost(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_BuyGP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XrPb::LogRoleBase* role_;
  uint32_t uisequence_;
  uint32_t uigp_;
  uint32_t uimb_;
  uint32_t uicost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_Log_RecordOnline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_Log_RecordOnline) */ {
 public:
  inline Msg_Log_RecordOnline() : Msg_Log_RecordOnline(nullptr) {}
  ~Msg_Log_RecordOnline() override;
  explicit constexpr Msg_Log_RecordOnline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_Log_RecordOnline(const Msg_Log_RecordOnline& from);
  Msg_Log_RecordOnline(Msg_Log_RecordOnline&& from) noexcept
    : Msg_Log_RecordOnline() {
    *this = ::std::move(from);
  }

  inline Msg_Log_RecordOnline& operator=(const Msg_Log_RecordOnline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_Log_RecordOnline& operator=(Msg_Log_RecordOnline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_Log_RecordOnline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_Log_RecordOnline* internal_default_instance() {
    return reinterpret_cast<const Msg_Log_RecordOnline*>(
               &_Msg_Log_RecordOnline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Msg_Log_RecordOnline& a, Msg_Log_RecordOnline& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_Log_RecordOnline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_Log_RecordOnline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_Log_RecordOnline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_Log_RecordOnline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_Log_RecordOnline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_Log_RecordOnline& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_Log_RecordOnline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_Log_RecordOnline";
  }
  protected:
  explicit Msg_Log_RecordOnline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreannoFieldNumber = 1,
    kOnlineNumFieldNumber = 2,
    kTimeFieldNumber = 3,
    kPlatidFieldNumber = 4,
  };
  // uint32 areanno = 1;
  void clear_areanno();
  uint32_t areanno() const;
  void set_areanno(uint32_t value);
  private:
  uint32_t _internal_areanno() const;
  void _internal_set_areanno(uint32_t value);
  public:

  // optional uint32 online_num = 2;
  bool has_online_num() const;
  private:
  bool _internal_has_online_num() const;
  public:
  void clear_online_num();
  uint32_t online_num() const;
  void set_online_num(uint32_t value);
  private:
  uint32_t _internal_online_num() const;
  void _internal_set_online_num(uint32_t value);
  public:

  // optional int64 time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // optional uint32 platid = 4;
  bool has_platid() const;
  private:
  bool _internal_has_platid() const;
  public:
  void clear_platid();
  uint32_t platid() const;
  void set_platid(uint32_t value);
  private:
  uint32_t _internal_platid() const;
  void _internal_set_platid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_Log_RecordOnline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t areanno_;
  uint32_t online_num_;
  int64_t time_;
  uint32_t platid_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_Log_CreateRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_Log_CreateRole) */ {
 public:
  inline Msg_Log_CreateRole() : Msg_Log_CreateRole(nullptr) {}
  ~Msg_Log_CreateRole() override;
  explicit constexpr Msg_Log_CreateRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_Log_CreateRole(const Msg_Log_CreateRole& from);
  Msg_Log_CreateRole(Msg_Log_CreateRole&& from) noexcept
    : Msg_Log_CreateRole() {
    *this = ::std::move(from);
  }

  inline Msg_Log_CreateRole& operator=(const Msg_Log_CreateRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_Log_CreateRole& operator=(Msg_Log_CreateRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_Log_CreateRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_Log_CreateRole* internal_default_instance() {
    return reinterpret_cast<const Msg_Log_CreateRole*>(
               &_Msg_Log_CreateRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Msg_Log_CreateRole& a, Msg_Log_CreateRole& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_Log_CreateRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_Log_CreateRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_Log_CreateRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_Log_CreateRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_Log_CreateRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_Log_CreateRole& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_Log_CreateRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_Log_CreateRole";
  }
  protected:
  explicit Msg_Log_CreateRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolenameFieldNumber = 2,
    kRoleFieldNumber = 1,
  };
  // string rolename = 2;
  void clear_rolename();
  const std::string& rolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rolename();
  PROTOBUF_NODISCARD std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);
  private:
  const std::string& _internal_rolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rolename(const std::string& value);
  std::string* _internal_mutable_rolename();
  public:

  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_Log_CreateRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  ::XrPb::LogRoleBase* role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_Log_ModifyRoleName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_Log_ModifyRoleName) */ {
 public:
  inline Msg_Log_ModifyRoleName() : Msg_Log_ModifyRoleName(nullptr) {}
  ~Msg_Log_ModifyRoleName() override;
  explicit constexpr Msg_Log_ModifyRoleName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_Log_ModifyRoleName(const Msg_Log_ModifyRoleName& from);
  Msg_Log_ModifyRoleName(Msg_Log_ModifyRoleName&& from) noexcept
    : Msg_Log_ModifyRoleName() {
    *this = ::std::move(from);
  }

  inline Msg_Log_ModifyRoleName& operator=(const Msg_Log_ModifyRoleName& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_Log_ModifyRoleName& operator=(Msg_Log_ModifyRoleName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_Log_ModifyRoleName& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_Log_ModifyRoleName* internal_default_instance() {
    return reinterpret_cast<const Msg_Log_ModifyRoleName*>(
               &_Msg_Log_ModifyRoleName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Msg_Log_ModifyRoleName& a, Msg_Log_ModifyRoleName& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_Log_ModifyRoleName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_Log_ModifyRoleName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_Log_ModifyRoleName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_Log_ModifyRoleName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_Log_ModifyRoleName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_Log_ModifyRoleName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_Log_ModifyRoleName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_Log_ModifyRoleName";
  }
  protected:
  explicit Msg_Log_ModifyRoleName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolenameFieldNumber = 2,
    kOldRolenameFieldNumber = 3,
    kRoleFieldNumber = 1,
  };
  // string rolename = 2;
  void clear_rolename();
  const std::string& rolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rolename();
  PROTOBUF_NODISCARD std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);
  private:
  const std::string& _internal_rolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rolename(const std::string& value);
  std::string* _internal_mutable_rolename();
  public:

  // string old_rolename = 3;
  void clear_old_rolename();
  const std::string& old_rolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_rolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_rolename();
  PROTOBUF_NODISCARD std::string* release_old_rolename();
  void set_allocated_old_rolename(std::string* old_rolename);
  private:
  const std::string& _internal_old_rolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_rolename(const std::string& value);
  std::string* _internal_mutable_old_rolename();
  public:

  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_Log_ModifyRoleName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_rolename_;
  ::XrPb::LogRoleBase* role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// -------------------------------------------------------------------

class Msg_LOG_RoleChatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_LOG_RoleChatMsg) */ {
 public:
  inline Msg_LOG_RoleChatMsg() : Msg_LOG_RoleChatMsg(nullptr) {}
  ~Msg_LOG_RoleChatMsg() override;
  explicit constexpr Msg_LOG_RoleChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_LOG_RoleChatMsg(const Msg_LOG_RoleChatMsg& from);
  Msg_LOG_RoleChatMsg(Msg_LOG_RoleChatMsg&& from) noexcept
    : Msg_LOG_RoleChatMsg() {
    *this = ::std::move(from);
  }

  inline Msg_LOG_RoleChatMsg& operator=(const Msg_LOG_RoleChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_LOG_RoleChatMsg& operator=(Msg_LOG_RoleChatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_LOG_RoleChatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_LOG_RoleChatMsg* internal_default_instance() {
    return reinterpret_cast<const Msg_LOG_RoleChatMsg*>(
               &_Msg_LOG_RoleChatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Msg_LOG_RoleChatMsg& a, Msg_LOG_RoleChatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_LOG_RoleChatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_LOG_RoleChatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_LOG_RoleChatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_LOG_RoleChatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_LOG_RoleChatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_LOG_RoleChatMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_LOG_RoleChatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_LOG_RoleChatMsg";
  }
  protected:
  explicit Msg_LOG_RoleChatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kRoleFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .XrPb.LogRoleBase role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::LogRoleBase& role() const;
  PROTOBUF_NODISCARD ::XrPb::LogRoleBase* release_role();
  ::XrPb::LogRoleBase* mutable_role();
  void set_allocated_role(::XrPb::LogRoleBase* role);
  private:
  const ::XrPb::LogRoleBase& _internal_role() const;
  ::XrPb::LogRoleBase* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::LogRoleBase* role);
  ::XrPb::LogRoleBase* unsafe_arena_release_role();

  // .XrPb.EChatType type = 2;
  void clear_type();
  ::XrPb::EChatType type() const;
  void set_type(::XrPb::EChatType value);
  private:
  ::XrPb::EChatType _internal_type() const;
  void _internal_set_type(::XrPb::EChatType value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_LOG_RoleChatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::XrPb::LogRoleBase* role_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgLog_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgSvrMod_Log

// -------------------------------------------------------------------

// LogRoleBase

// int64 acc_id = 1;
inline void LogRoleBase::clear_acc_id() {
  acc_id_ = int64_t{0};
}
inline int64_t LogRoleBase::_internal_acc_id() const {
  return acc_id_;
}
inline int64_t LogRoleBase::acc_id() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.acc_id)
  return _internal_acc_id();
}
inline void LogRoleBase::_internal_set_acc_id(int64_t value) {
  
  acc_id_ = value;
}
inline void LogRoleBase::set_acc_id(int64_t value) {
  _internal_set_acc_id(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.acc_id)
}

// uint32 level = 2;
inline void LogRoleBase::clear_level() {
  level_ = 0u;
}
inline uint32_t LogRoleBase::_internal_level() const {
  return level_;
}
inline uint32_t LogRoleBase::level() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.level)
  return _internal_level();
}
inline void LogRoleBase::_internal_set_level(uint32_t value) {
  
  level_ = value;
}
inline void LogRoleBase::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.level)
}

// uint32 arena_type = 3;
inline void LogRoleBase::clear_arena_type() {
  arena_type_ = 0u;
}
inline uint32_t LogRoleBase::_internal_arena_type() const {
  return arena_type_;
}
inline uint32_t LogRoleBase::arena_type() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.arena_type)
  return _internal_arena_type();
}
inline void LogRoleBase::_internal_set_arena_type(uint32_t value) {
  
  arena_type_ = value;
}
inline void LogRoleBase::set_arena_type(uint32_t value) {
  _internal_set_arena_type(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.arena_type)
}

// uint32 arena_level = 4;
inline void LogRoleBase::clear_arena_level() {
  arena_level_ = 0u;
}
inline uint32_t LogRoleBase::_internal_arena_level() const {
  return arena_level_;
}
inline uint32_t LogRoleBase::arena_level() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.arena_level)
  return _internal_arena_level();
}
inline void LogRoleBase::_internal_set_arena_level(uint32_t value) {
  
  arena_level_ = value;
}
inline void LogRoleBase::set_arena_level(uint32_t value) {
  _internal_set_arena_level(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.arena_level)
}

// optional string dev_id = 5;
inline bool LogRoleBase::_internal_has_dev_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogRoleBase::has_dev_id() const {
  return _internal_has_dev_id();
}
inline void LogRoleBase::clear_dev_id() {
  dev_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogRoleBase::dev_id() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.dev_id)
  return _internal_dev_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRoleBase::set_dev_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 dev_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.dev_id)
}
inline std::string* LogRoleBase::mutable_dev_id() {
  std::string* _s = _internal_mutable_dev_id();
  // @@protoc_insertion_point(field_mutable:XrPb.LogRoleBase.dev_id)
  return _s;
}
inline const std::string& LogRoleBase::_internal_dev_id() const {
  return dev_id_.Get();
}
inline void LogRoleBase::_internal_set_dev_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dev_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogRoleBase::_internal_mutable_dev_id() {
  _has_bits_[0] |= 0x00000001u;
  return dev_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogRoleBase::release_dev_id() {
  // @@protoc_insertion_point(field_release:XrPb.LogRoleBase.dev_id)
  if (!_internal_has_dev_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = dev_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dev_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dev_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogRoleBase::set_allocated_dev_id(std::string* dev_id) {
  if (dev_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dev_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dev_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dev_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dev_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.LogRoleBase.dev_id)
}

// optional uint32 areanno = 6;
inline bool LogRoleBase::_internal_has_areanno() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogRoleBase::has_areanno() const {
  return _internal_has_areanno();
}
inline void LogRoleBase::clear_areanno() {
  areanno_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LogRoleBase::_internal_areanno() const {
  return areanno_;
}
inline uint32_t LogRoleBase::areanno() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.areanno)
  return _internal_areanno();
}
inline void LogRoleBase::_internal_set_areanno(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  areanno_ = value;
}
inline void LogRoleBase::set_areanno(uint32_t value) {
  _internal_set_areanno(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.areanno)
}

// optional int64 time = 7;
inline bool LogRoleBase::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogRoleBase::has_time() const {
  return _internal_has_time();
}
inline void LogRoleBase::clear_time() {
  time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t LogRoleBase::_internal_time() const {
  return time_;
}
inline int64_t LogRoleBase::time() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.time)
  return _internal_time();
}
inline void LogRoleBase::_internal_set_time(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  time_ = value;
}
inline void LogRoleBase::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.time)
}

// optional uint32 platid = 8;
inline bool LogRoleBase::_internal_has_platid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LogRoleBase::has_platid() const {
  return _internal_has_platid();
}
inline void LogRoleBase::clear_platid() {
  platid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LogRoleBase::_internal_platid() const {
  return platid_;
}
inline uint32_t LogRoleBase::platid() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.platid)
  return _internal_platid();
}
inline void LogRoleBase::_internal_set_platid(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  platid_ = value;
}
inline void LogRoleBase::set_platid(uint32_t value) {
  _internal_set_platid(value);
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.platid)
}

// optional string channel = 9;
inline bool LogRoleBase::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogRoleBase::has_channel() const {
  return _internal_has_channel();
}
inline void LogRoleBase::clear_channel() {
  channel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LogRoleBase::channel() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRoleBase::set_channel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 channel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.channel)
}
inline std::string* LogRoleBase::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:XrPb.LogRoleBase.channel)
  return _s;
}
inline const std::string& LogRoleBase::_internal_channel() const {
  return channel_.Get();
}
inline void LogRoleBase::_internal_set_channel(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  channel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogRoleBase::_internal_mutable_channel() {
  _has_bits_[0] |= 0x00000002u;
  return channel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogRoleBase::release_channel() {
  // @@protoc_insertion_point(field_release:XrPb.LogRoleBase.channel)
  if (!_internal_has_channel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = channel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogRoleBase::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  channel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.LogRoleBase.channel)
}

// optional string role_name = 10;
inline bool LogRoleBase::_internal_has_role_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogRoleBase::has_role_name() const {
  return _internal_has_role_name();
}
inline void LogRoleBase::clear_role_name() {
  role_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LogRoleBase::role_name() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRoleBase::set_role_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 role_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.role_name)
}
inline std::string* LogRoleBase::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:XrPb.LogRoleBase.role_name)
  return _s;
}
inline const std::string& LogRoleBase::_internal_role_name() const {
  return role_name_.Get();
}
inline void LogRoleBase::_internal_set_role_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  role_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogRoleBase::_internal_mutable_role_name() {
  _has_bits_[0] |= 0x00000004u;
  return role_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogRoleBase::release_role_name() {
  // @@protoc_insertion_point(field_release:XrPb.LogRoleBase.role_name)
  if (!_internal_has_role_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = role_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (role_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    role_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogRoleBase::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  role_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (role_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    role_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.LogRoleBase.role_name)
}

// optional string client_ip = 11;
inline bool LogRoleBase::_internal_has_client_ip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogRoleBase::has_client_ip() const {
  return _internal_has_client_ip();
}
inline void LogRoleBase::clear_client_ip() {
  client_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LogRoleBase::client_ip() const {
  // @@protoc_insertion_point(field_get:XrPb.LogRoleBase.client_ip)
  return _internal_client_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRoleBase::set_client_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 client_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.LogRoleBase.client_ip)
}
inline std::string* LogRoleBase::mutable_client_ip() {
  std::string* _s = _internal_mutable_client_ip();
  // @@protoc_insertion_point(field_mutable:XrPb.LogRoleBase.client_ip)
  return _s;
}
inline const std::string& LogRoleBase::_internal_client_ip() const {
  return client_ip_.Get();
}
inline void LogRoleBase::_internal_set_client_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  client_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogRoleBase::_internal_mutable_client_ip() {
  _has_bits_[0] |= 0x00000008u;
  return client_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogRoleBase::release_client_ip() {
  // @@protoc_insertion_point(field_release:XrPb.LogRoleBase.client_ip)
  if (!_internal_has_client_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = client_ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogRoleBase::set_allocated_client_ip(std::string* client_ip) {
  if (client_ip != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  client_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.LogRoleBase.client_ip)
}

// -------------------------------------------------------------------

// Msg_Log_UpLoadFile

// optional uint32 areano = 1;
inline bool Msg_Log_UpLoadFile::_internal_has_areano() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_areano() const {
  return _internal_has_areano();
}
inline void Msg_Log_UpLoadFile::clear_areano() {
  areano_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Msg_Log_UpLoadFile::_internal_areano() const {
  return areano_;
}
inline uint32_t Msg_Log_UpLoadFile::areano() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.areano)
  return _internal_areano();
}
inline void Msg_Log_UpLoadFile::_internal_set_areano(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  areano_ = value;
}
inline void Msg_Log_UpLoadFile::set_areano(uint32_t value) {
  _internal_set_areano(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.areano)
}

// optional int64 roomid = 2;
inline bool Msg_Log_UpLoadFile::_internal_has_roomid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_roomid() const {
  return _internal_has_roomid();
}
inline void Msg_Log_UpLoadFile::clear_roomid() {
  roomid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t Msg_Log_UpLoadFile::_internal_roomid() const {
  return roomid_;
}
inline int64_t Msg_Log_UpLoadFile::roomid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.roomid)
  return _internal_roomid();
}
inline void Msg_Log_UpLoadFile::_internal_set_roomid(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  roomid_ = value;
}
inline void Msg_Log_UpLoadFile::set_roomid(int64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.roomid)
}

// optional string roomLog = 3;
inline bool Msg_Log_UpLoadFile::_internal_has_roomlog() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_roomlog() const {
  return _internal_has_roomlog();
}
inline void Msg_Log_UpLoadFile::clear_roomlog() {
  roomlog_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Msg_Log_UpLoadFile::roomlog() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.roomLog)
  return _internal_roomlog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_Log_UpLoadFile::set_roomlog(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 roomlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.roomLog)
}
inline std::string* Msg_Log_UpLoadFile::mutable_roomlog() {
  std::string* _s = _internal_mutable_roomlog();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_UpLoadFile.roomLog)
  return _s;
}
inline const std::string& Msg_Log_UpLoadFile::_internal_roomlog() const {
  return roomlog_.Get();
}
inline void Msg_Log_UpLoadFile::_internal_set_roomlog(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  roomlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_Log_UpLoadFile::_internal_mutable_roomlog() {
  _has_bits_[0] |= 0x00000001u;
  return roomlog_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_Log_UpLoadFile::release_roomlog() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_UpLoadFile.roomLog)
  if (!_internal_has_roomlog()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = roomlog_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomlog_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roomlog_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Msg_Log_UpLoadFile::set_allocated_roomlog(std::string* roomlog) {
  if (roomlog != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  roomlog_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomlog,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomlog_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roomlog_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_UpLoadFile.roomLog)
}

// optional string logpath = 4;
inline bool Msg_Log_UpLoadFile::_internal_has_logpath() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_logpath() const {
  return _internal_has_logpath();
}
inline void Msg_Log_UpLoadFile::clear_logpath() {
  logpath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Msg_Log_UpLoadFile::logpath() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.logpath)
  return _internal_logpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_Log_UpLoadFile::set_logpath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 logpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.logpath)
}
inline std::string* Msg_Log_UpLoadFile::mutable_logpath() {
  std::string* _s = _internal_mutable_logpath();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_UpLoadFile.logpath)
  return _s;
}
inline const std::string& Msg_Log_UpLoadFile::_internal_logpath() const {
  return logpath_.Get();
}
inline void Msg_Log_UpLoadFile::_internal_set_logpath(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  logpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_Log_UpLoadFile::_internal_mutable_logpath() {
  _has_bits_[0] |= 0x00000002u;
  return logpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_Log_UpLoadFile::release_logpath() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_UpLoadFile.logpath)
  if (!_internal_has_logpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = logpath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    logpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Msg_Log_UpLoadFile::set_allocated_logpath(std::string* logpath) {
  if (logpath != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  logpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logpath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    logpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_UpLoadFile.logpath)
}

// optional uint32 serverid = 5;
inline bool Msg_Log_UpLoadFile::_internal_has_serverid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_serverid() const {
  return _internal_has_serverid();
}
inline void Msg_Log_UpLoadFile::clear_serverid() {
  serverid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Msg_Log_UpLoadFile::_internal_serverid() const {
  return serverid_;
}
inline uint32_t Msg_Log_UpLoadFile::serverid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.serverid)
  return _internal_serverid();
}
inline void Msg_Log_UpLoadFile::_internal_set_serverid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  serverid_ = value;
}
inline void Msg_Log_UpLoadFile::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.serverid)
}

// optional uint32 size = 6;
inline bool Msg_Log_UpLoadFile::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_size() const {
  return _internal_has_size();
}
inline void Msg_Log_UpLoadFile::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Msg_Log_UpLoadFile::_internal_size() const {
  return size_;
}
inline uint32_t Msg_Log_UpLoadFile::size() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.size)
  return _internal_size();
}
inline void Msg_Log_UpLoadFile::_internal_set_size(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  size_ = value;
}
inline void Msg_Log_UpLoadFile::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.size)
}

// optional bool failres = 7;
inline bool Msg_Log_UpLoadFile::_internal_has_failres() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Msg_Log_UpLoadFile::has_failres() const {
  return _internal_has_failres();
}
inline void Msg_Log_UpLoadFile::clear_failres() {
  failres_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Msg_Log_UpLoadFile::_internal_failres() const {
  return failres_;
}
inline bool Msg_Log_UpLoadFile::failres() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_UpLoadFile.failres)
  return _internal_failres();
}
inline void Msg_Log_UpLoadFile::_internal_set_failres(bool value) {
  _has_bits_[0] |= 0x00000040u;
  failres_ = value;
}
inline void Msg_Log_UpLoadFile::set_failres(bool value) {
  _internal_set_failres(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_UpLoadFile.failres)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleLoginLogout

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleLoginLogout::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleLoginLogout::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleLoginLogout::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleLoginLogout::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.role)
  return _internal_role();
}
inline void Msg_LOG_RoleLoginLogout::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleLoginLogout.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleLoginLogout::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleLoginLogout::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleLoginLogout.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleLoginLogout::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleLoginLogout::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleLoginLogout.role)
  return _msg;
}
inline void Msg_LOG_RoleLoginLogout::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleLoginLogout.role)
}

// optional uint32 in_out = 2;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_in_out() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_in_out() const {
  return _internal_has_in_out();
}
inline void Msg_LOG_RoleLoginLogout::clear_in_out() {
  in_out_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Msg_LOG_RoleLoginLogout::_internal_in_out() const {
  return in_out_;
}
inline uint32_t Msg_LOG_RoleLoginLogout::in_out() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.in_out)
  return _internal_in_out();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_in_out(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  in_out_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_in_out(uint32_t value) {
  _internal_set_in_out(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.in_out)
}

// optional int64 enter_time = 3;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_enter_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_enter_time() const {
  return _internal_has_enter_time();
}
inline void Msg_LOG_RoleLoginLogout::clear_enter_time() {
  enter_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Msg_LOG_RoleLoginLogout::_internal_enter_time() const {
  return enter_time_;
}
inline int64_t Msg_LOG_RoleLoginLogout::enter_time() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.enter_time)
  return _internal_enter_time();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_enter_time(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  enter_time_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_enter_time(int64_t value) {
  _internal_set_enter_time(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.enter_time)
}

// optional uint32 coin_GP = 4;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_coin_gp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_coin_gp() const {
  return _internal_has_coin_gp();
}
inline void Msg_LOG_RoleLoginLogout::clear_coin_gp() {
  coin_gp_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Msg_LOG_RoleLoginLogout::_internal_coin_gp() const {
  return coin_gp_;
}
inline uint32_t Msg_LOG_RoleLoginLogout::coin_gp() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.coin_GP)
  return _internal_coin_gp();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_coin_gp(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  coin_gp_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_coin_gp(uint32_t value) {
  _internal_set_coin_gp(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.coin_GP)
}

// optional uint32 coin_MB = 5;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_coin_mb() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_coin_mb() const {
  return _internal_has_coin_mb();
}
inline void Msg_LOG_RoleLoginLogout::clear_coin_mb() {
  coin_mb_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Msg_LOG_RoleLoginLogout::_internal_coin_mb() const {
  return coin_mb_;
}
inline uint32_t Msg_LOG_RoleLoginLogout::coin_mb() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.coin_MB)
  return _internal_coin_mb();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_coin_mb(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  coin_mb_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_coin_mb(uint32_t value) {
  _internal_set_coin_mb(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.coin_MB)
}

// optional bool vip = 6;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_vip() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_vip() const {
  return _internal_has_vip();
}
inline void Msg_LOG_RoleLoginLogout::clear_vip() {
  vip_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Msg_LOG_RoleLoginLogout::_internal_vip() const {
  return vip_;
}
inline bool Msg_LOG_RoleLoginLogout::vip() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.vip)
  return _internal_vip();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_vip(bool value) {
  _has_bits_[0] |= 0x00000010u;
  vip_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_vip(bool value) {
  _internal_set_vip(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.vip)
}

// optional int64 leave_time = 7;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_leave_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Msg_LOG_RoleLoginLogout::has_leave_time() const {
  return _internal_has_leave_time();
}
inline void Msg_LOG_RoleLoginLogout::clear_leave_time() {
  leave_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t Msg_LOG_RoleLoginLogout::_internal_leave_time() const {
  return leave_time_;
}
inline int64_t Msg_LOG_RoleLoginLogout::leave_time() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.leave_time)
  return _internal_leave_time();
}
inline void Msg_LOG_RoleLoginLogout::_internal_set_leave_time(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  leave_time_ = value;
}
inline void Msg_LOG_RoleLoginLogout::set_leave_time(int64_t value) {
  _internal_set_leave_time(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleLoginLogout.leave_time)
}

// .XrPb.GameVersion game_version = 8;
inline bool Msg_LOG_RoleLoginLogout::_internal_has_game_version() const {
  return this != internal_default_instance() && game_version_ != nullptr;
}
inline bool Msg_LOG_RoleLoginLogout::has_game_version() const {
  return _internal_has_game_version();
}
inline const ::XrPb::GameVersion& Msg_LOG_RoleLoginLogout::_internal_game_version() const {
  const ::XrPb::GameVersion* p = game_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::GameVersion&>(
      ::XrPb::_GameVersion_default_instance_);
}
inline const ::XrPb::GameVersion& Msg_LOG_RoleLoginLogout::game_version() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleLoginLogout.game_version)
  return _internal_game_version();
}
inline void Msg_LOG_RoleLoginLogout::unsafe_arena_set_allocated_game_version(
    ::XrPb::GameVersion* game_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_version_);
  }
  game_version_ = game_version;
  if (game_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleLoginLogout.game_version)
}
inline ::XrPb::GameVersion* Msg_LOG_RoleLoginLogout::release_game_version() {
  
  ::XrPb::GameVersion* temp = game_version_;
  game_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::GameVersion* Msg_LOG_RoleLoginLogout::unsafe_arena_release_game_version() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleLoginLogout.game_version)
  
  ::XrPb::GameVersion* temp = game_version_;
  game_version_ = nullptr;
  return temp;
}
inline ::XrPb::GameVersion* Msg_LOG_RoleLoginLogout::_internal_mutable_game_version() {
  
  if (game_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::GameVersion>(GetArenaForAllocation());
    game_version_ = p;
  }
  return game_version_;
}
inline ::XrPb::GameVersion* Msg_LOG_RoleLoginLogout::mutable_game_version() {
  ::XrPb::GameVersion* _msg = _internal_mutable_game_version();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleLoginLogout.game_version)
  return _msg;
}
inline void Msg_LOG_RoleLoginLogout::set_allocated_game_version(::XrPb::GameVersion* game_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_version_);
  }
  if (game_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_version));
    if (message_arena != submessage_arena) {
      game_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_version, submessage_arena);
    }
    
  } else {
    
  }
  game_version_ = game_version;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleLoginLogout.game_version)
}

// -------------------------------------------------------------------

// ItemLogInfo

// optional int32 type = 1;
inline bool ItemLogInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemLogInfo::has_type() const {
  return _internal_has_type();
}
inline void ItemLogInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ItemLogInfo::_internal_type() const {
  return type_;
}
inline int32_t ItemLogInfo::type() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.type)
  return _internal_type();
}
inline void ItemLogInfo::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ItemLogInfo::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.type)
}

// optional uint32 id = 2;
inline bool ItemLogInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemLogInfo::has_id() const {
  return _internal_has_id();
}
inline void ItemLogInfo::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemLogInfo::_internal_id() const {
  return id_;
}
inline uint32_t ItemLogInfo::id() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.id)
  return _internal_id();
}
inline void ItemLogInfo::_internal_set_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void ItemLogInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.id)
}

// optional int32 new_val = 3;
inline bool ItemLogInfo::_internal_has_new_val() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemLogInfo::has_new_val() const {
  return _internal_has_new_val();
}
inline void ItemLogInfo::clear_new_val() {
  new_val_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ItemLogInfo::_internal_new_val() const {
  return new_val_;
}
inline int32_t ItemLogInfo::new_val() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.new_val)
  return _internal_new_val();
}
inline void ItemLogInfo::_internal_set_new_val(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  new_val_ = value;
}
inline void ItemLogInfo::set_new_val(int32_t value) {
  _internal_set_new_val(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.new_val)
}

// optional int32 old_val = 4;
inline bool ItemLogInfo::_internal_has_old_val() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemLogInfo::has_old_val() const {
  return _internal_has_old_val();
}
inline void ItemLogInfo::clear_old_val() {
  old_val_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ItemLogInfo::_internal_old_val() const {
  return old_val_;
}
inline int32_t ItemLogInfo::old_val() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.old_val)
  return _internal_old_val();
}
inline void ItemLogInfo::_internal_set_old_val(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  old_val_ = value;
}
inline void ItemLogInfo::set_old_val(int32_t value) {
  _internal_set_old_val(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.old_val)
}

// optional .XrPb.EFromType from = 5;
inline bool ItemLogInfo::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemLogInfo::has_from() const {
  return _internal_has_from();
}
inline void ItemLogInfo::clear_from() {
  from_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::XrPb::EFromType ItemLogInfo::_internal_from() const {
  return static_cast< ::XrPb::EFromType >(from_);
}
inline ::XrPb::EFromType ItemLogInfo::from() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.from)
  return _internal_from();
}
inline void ItemLogInfo::_internal_set_from(::XrPb::EFromType value) {
  _has_bits_[0] |= 0x00000010u;
  from_ = value;
}
inline void ItemLogInfo::set_from(::XrPb::EFromType value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.from)
}

// optional .XrPb.EToType to = 6;
inline bool ItemLogInfo::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemLogInfo::has_to() const {
  return _internal_has_to();
}
inline void ItemLogInfo::clear_to() {
  to_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::XrPb::EToType ItemLogInfo::_internal_to() const {
  return static_cast< ::XrPb::EToType >(to_);
}
inline ::XrPb::EToType ItemLogInfo::to() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.to)
  return _internal_to();
}
inline void ItemLogInfo::_internal_set_to(::XrPb::EToType value) {
  _has_bits_[0] |= 0x00000020u;
  to_ = value;
}
inline void ItemLogInfo::set_to(::XrPb::EToType value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.to)
}

// optional int64 get_id = 7;
inline bool ItemLogInfo::_internal_has_get_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemLogInfo::has_get_id() const {
  return _internal_has_get_id();
}
inline void ItemLogInfo::clear_get_id() {
  get_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t ItemLogInfo::_internal_get_id() const {
  return get_id_;
}
inline int64_t ItemLogInfo::get_id() const {
  // @@protoc_insertion_point(field_get:XrPb.ItemLogInfo.get_id)
  return _internal_get_id();
}
inline void ItemLogInfo::_internal_set_get_id(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  get_id_ = value;
}
inline void ItemLogInfo::set_get_id(int64_t value) {
  _internal_set_get_id(value);
  // @@protoc_insertion_point(field_set:XrPb.ItemLogInfo.get_id)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleItem

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleItem::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleItem::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleItem::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleItem::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleItem::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleItem.role)
  return _internal_role();
}
inline void Msg_LOG_RoleItem::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleItem.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleItem::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleItem::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleItem.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleItem::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleItem::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleItem.role)
  return _msg;
}
inline void Msg_LOG_RoleItem::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleItem.role)
}

// optional string comment = 2;
inline bool Msg_LOG_RoleItem::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_RoleItem::has_comment() const {
  return _internal_has_comment();
}
inline void Msg_LOG_RoleItem::clear_comment() {
  comment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Msg_LOG_RoleItem::comment() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleItem.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_LOG_RoleItem::set_comment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleItem.comment)
}
inline std::string* Msg_LOG_RoleItem::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleItem.comment)
  return _s;
}
inline const std::string& Msg_LOG_RoleItem::_internal_comment() const {
  return comment_.Get();
}
inline void Msg_LOG_RoleItem::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_LOG_RoleItem::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000001u;
  return comment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_LOG_RoleItem::release_comment() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleItem.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Msg_LOG_RoleItem::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (comment_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleItem.comment)
}

// .XrPb.ItemLogInfo items = 3;
inline bool Msg_LOG_RoleItem::_internal_has_items() const {
  return this != internal_default_instance() && items_ != nullptr;
}
inline bool Msg_LOG_RoleItem::has_items() const {
  return _internal_has_items();
}
inline void Msg_LOG_RoleItem::clear_items() {
  if (GetArenaForAllocation() == nullptr && items_ != nullptr) {
    delete items_;
  }
  items_ = nullptr;
}
inline const ::XrPb::ItemLogInfo& Msg_LOG_RoleItem::_internal_items() const {
  const ::XrPb::ItemLogInfo* p = items_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::ItemLogInfo&>(
      ::XrPb::_ItemLogInfo_default_instance_);
}
inline const ::XrPb::ItemLogInfo& Msg_LOG_RoleItem::items() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleItem.items)
  return _internal_items();
}
inline void Msg_LOG_RoleItem::unsafe_arena_set_allocated_items(
    ::XrPb::ItemLogInfo* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(items_);
  }
  items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleItem.items)
}
inline ::XrPb::ItemLogInfo* Msg_LOG_RoleItem::release_items() {
  
  ::XrPb::ItemLogInfo* temp = items_;
  items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::ItemLogInfo* Msg_LOG_RoleItem::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleItem.items)
  
  ::XrPb::ItemLogInfo* temp = items_;
  items_ = nullptr;
  return temp;
}
inline ::XrPb::ItemLogInfo* Msg_LOG_RoleItem::_internal_mutable_items() {
  
  if (items_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::ItemLogInfo>(GetArenaForAllocation());
    items_ = p;
  }
  return items_;
}
inline ::XrPb::ItemLogInfo* Msg_LOG_RoleItem::mutable_items() {
  ::XrPb::ItemLogInfo* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleItem.items)
  return _msg;
}
inline void Msg_LOG_RoleItem::set_allocated_items(::XrPb::ItemLogInfo* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete items_;
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::ItemLogInfo>::GetOwningArena(items);
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  items_ = items;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleItem.items)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleProgress

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleProgress::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleProgress::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleProgress::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleProgress::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleProgress::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleProgress.role)
  return _internal_role();
}
inline void Msg_LOG_RoleProgress::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleProgress.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleProgress::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleProgress::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleProgress.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleProgress::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleProgress::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleProgress.role)
  return _msg;
}
inline void Msg_LOG_RoleProgress::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleProgress.role)
}

// .XrPb.ELogProgressType type = 2;
inline void Msg_LOG_RoleProgress::clear_type() {
  type_ = 0;
}
inline ::XrPb::ELogProgressType Msg_LOG_RoleProgress::_internal_type() const {
  return static_cast< ::XrPb::ELogProgressType >(type_);
}
inline ::XrPb::ELogProgressType Msg_LOG_RoleProgress::type() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleProgress.type)
  return _internal_type();
}
inline void Msg_LOG_RoleProgress::_internal_set_type(::XrPb::ELogProgressType value) {
  
  type_ = value;
}
inline void Msg_LOG_RoleProgress::set_type(::XrPb::ELogProgressType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleProgress.type)
}

// optional uint32 progress = 3;
inline bool Msg_LOG_RoleProgress::_internal_has_progress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_RoleProgress::has_progress() const {
  return _internal_has_progress();
}
inline void Msg_LOG_RoleProgress::clear_progress() {
  progress_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Msg_LOG_RoleProgress::_internal_progress() const {
  return progress_;
}
inline uint32_t Msg_LOG_RoleProgress::progress() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleProgress.progress)
  return _internal_progress();
}
inline void Msg_LOG_RoleProgress::_internal_set_progress(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  progress_ = value;
}
inline void Msg_LOG_RoleProgress::set_progress(uint32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleProgress.progress)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleAttribute

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleAttribute::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleAttribute::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleAttribute::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleAttribute::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleAttribute::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.role)
  return _internal_role();
}
inline void Msg_LOG_RoleAttribute::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleAttribute.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleAttribute::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleAttribute::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleAttribute.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleAttribute::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleAttribute::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleAttribute.role)
  return _msg;
}
inline void Msg_LOG_RoleAttribute::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleAttribute.role)
}

// .XrPb.ELogAttrType type = 2;
inline void Msg_LOG_RoleAttribute::clear_type() {
  type_ = 0;
}
inline ::XrPb::ELogAttrType Msg_LOG_RoleAttribute::_internal_type() const {
  return static_cast< ::XrPb::ELogAttrType >(type_);
}
inline ::XrPb::ELogAttrType Msg_LOG_RoleAttribute::type() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.type)
  return _internal_type();
}
inline void Msg_LOG_RoleAttribute::_internal_set_type(::XrPb::ELogAttrType value) {
  
  type_ = value;
}
inline void Msg_LOG_RoleAttribute::set_type(::XrPb::ELogAttrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.type)
}

// optional uint32 level = 3;
inline bool Msg_LOG_RoleAttribute::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_RoleAttribute::has_level() const {
  return _internal_has_level();
}
inline void Msg_LOG_RoleAttribute::clear_level() {
  level_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Msg_LOG_RoleAttribute::_internal_level() const {
  return level_;
}
inline uint32_t Msg_LOG_RoleAttribute::level() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.level)
  return _internal_level();
}
inline void Msg_LOG_RoleAttribute::_internal_set_level(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  level_ = value;
}
inline void Msg_LOG_RoleAttribute::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.level)
}

// optional uint32 id = 4;
inline bool Msg_LOG_RoleAttribute::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_LOG_RoleAttribute::has_id() const {
  return _internal_has_id();
}
inline void Msg_LOG_RoleAttribute::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Msg_LOG_RoleAttribute::_internal_id() const {
  return id_;
}
inline uint32_t Msg_LOG_RoleAttribute::id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.id)
  return _internal_id();
}
inline void Msg_LOG_RoleAttribute::_internal_set_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void Msg_LOG_RoleAttribute::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.id)
}

// optional uint32 exp = 5;
inline bool Msg_LOG_RoleAttribute::_internal_has_exp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_LOG_RoleAttribute::has_exp() const {
  return _internal_has_exp();
}
inline void Msg_LOG_RoleAttribute::clear_exp() {
  exp_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Msg_LOG_RoleAttribute::_internal_exp() const {
  return exp_;
}
inline uint32_t Msg_LOG_RoleAttribute::exp() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.exp)
  return _internal_exp();
}
inline void Msg_LOG_RoleAttribute::_internal_set_exp(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  exp_ = value;
}
inline void Msg_LOG_RoleAttribute::set_exp(uint32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.exp)
}

// optional .XrPb.EFromType from = 6;
inline bool Msg_LOG_RoleAttribute::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Msg_LOG_RoleAttribute::has_from() const {
  return _internal_has_from();
}
inline void Msg_LOG_RoleAttribute::clear_from() {
  from_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::XrPb::EFromType Msg_LOG_RoleAttribute::_internal_from() const {
  return static_cast< ::XrPb::EFromType >(from_);
}
inline ::XrPb::EFromType Msg_LOG_RoleAttribute::from() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.from)
  return _internal_from();
}
inline void Msg_LOG_RoleAttribute::_internal_set_from(::XrPb::EFromType value) {
  _has_bits_[0] |= 0x00000008u;
  from_ = value;
}
inline void Msg_LOG_RoleAttribute::set_from(::XrPb::EFromType value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.from)
}

// optional uint32 config_id = 7;
inline bool Msg_LOG_RoleAttribute::_internal_has_config_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Msg_LOG_RoleAttribute::has_config_id() const {
  return _internal_has_config_id();
}
inline void Msg_LOG_RoleAttribute::clear_config_id() {
  config_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Msg_LOG_RoleAttribute::_internal_config_id() const {
  return config_id_;
}
inline uint32_t Msg_LOG_RoleAttribute::config_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleAttribute.config_id)
  return _internal_config_id();
}
inline void Msg_LOG_RoleAttribute::_internal_set_config_id(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  config_id_ = value;
}
inline void Msg_LOG_RoleAttribute::set_config_id(uint32_t value) {
  _internal_set_config_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleAttribute.config_id)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleFriend

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleFriend::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleFriend::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleFriend::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleFriend::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleFriend::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleFriend.role)
  return _internal_role();
}
inline void Msg_LOG_RoleFriend::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleFriend.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleFriend::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleFriend::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleFriend.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleFriend::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleFriend::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleFriend.role)
  return _msg;
}
inline void Msg_LOG_RoleFriend::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleFriend.role)
}

// .XrPb.ELogFriendType type = 2;
inline void Msg_LOG_RoleFriend::clear_type() {
  type_ = 0;
}
inline ::XrPb::ELogFriendType Msg_LOG_RoleFriend::_internal_type() const {
  return static_cast< ::XrPb::ELogFriendType >(type_);
}
inline ::XrPb::ELogFriendType Msg_LOG_RoleFriend::type() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleFriend.type)
  return _internal_type();
}
inline void Msg_LOG_RoleFriend::_internal_set_type(::XrPb::ELogFriendType value) {
  
  type_ = value;
}
inline void Msg_LOG_RoleFriend::set_type(::XrPb::ELogFriendType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleFriend.type)
}

// optional int64 friend_id = 3;
inline bool Msg_LOG_RoleFriend::_internal_has_friend_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_RoleFriend::has_friend_id() const {
  return _internal_has_friend_id();
}
inline void Msg_LOG_RoleFriend::clear_friend_id() {
  friend_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Msg_LOG_RoleFriend::_internal_friend_id() const {
  return friend_id_;
}
inline int64_t Msg_LOG_RoleFriend::friend_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleFriend.friend_id)
  return _internal_friend_id();
}
inline void Msg_LOG_RoleFriend::_internal_set_friend_id(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  friend_id_ = value;
}
inline void Msg_LOG_RoleFriend::set_friend_id(int64_t value) {
  _internal_set_friend_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleFriend.friend_id)
}

// -------------------------------------------------------------------

// Msg_LOG_GMRecord

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_GMRecord::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_GMRecord::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_GMRecord::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_GMRecord::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_GMRecord::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_GMRecord.role)
  return _internal_role();
}
inline void Msg_LOG_GMRecord::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_GMRecord.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_GMRecord::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_GMRecord::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_GMRecord.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_GMRecord::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_GMRecord::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_GMRecord.role)
  return _msg;
}
inline void Msg_LOG_GMRecord::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_GMRecord.role)
}

// string gm = 2;
inline void Msg_LOG_GMRecord::clear_gm() {
  gm_.ClearToEmpty();
}
inline const std::string& Msg_LOG_GMRecord::gm() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_GMRecord.gm)
  return _internal_gm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_LOG_GMRecord::set_gm(ArgT0&& arg0, ArgT... args) {
 
 gm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_GMRecord.gm)
}
inline std::string* Msg_LOG_GMRecord::mutable_gm() {
  std::string* _s = _internal_mutable_gm();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_GMRecord.gm)
  return _s;
}
inline const std::string& Msg_LOG_GMRecord::_internal_gm() const {
  return gm_.Get();
}
inline void Msg_LOG_GMRecord::_internal_set_gm(const std::string& value) {
  
  gm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_LOG_GMRecord::_internal_mutable_gm() {
  
  return gm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_LOG_GMRecord::release_gm() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_GMRecord.gm)
  return gm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Msg_LOG_GMRecord::set_allocated_gm(std::string* gm) {
  if (gm != nullptr) {
    
  } else {
    
  }
  gm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_GMRecord.gm)
}

// -------------------------------------------------------------------

// Msg_LOG_BuyMB

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_BuyMB::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_BuyMB::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_BuyMB::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_BuyMB::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_BuyMB::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.role)
  return _internal_role();
}
inline void Msg_LOG_BuyMB::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_BuyMB.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyMB::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyMB::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_BuyMB.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyMB::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyMB::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_BuyMB.role)
  return _msg;
}
inline void Msg_LOG_BuyMB::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_BuyMB.role)
}

// uint32 uiCharge = 2;
inline void Msg_LOG_BuyMB::clear_uicharge() {
  uicharge_ = 0u;
}
inline uint32_t Msg_LOG_BuyMB::_internal_uicharge() const {
  return uicharge_;
}
inline uint32_t Msg_LOG_BuyMB::uicharge() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.uiCharge)
  return _internal_uicharge();
}
inline void Msg_LOG_BuyMB::_internal_set_uicharge(uint32_t value) {
  
  uicharge_ = value;
}
inline void Msg_LOG_BuyMB::set_uicharge(uint32_t value) {
  _internal_set_uicharge(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.uiCharge)
}

// uint32 uiTotal = 3;
inline void Msg_LOG_BuyMB::clear_uitotal() {
  uitotal_ = 0u;
}
inline uint32_t Msg_LOG_BuyMB::_internal_uitotal() const {
  return uitotal_;
}
inline uint32_t Msg_LOG_BuyMB::uitotal() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.uiTotal)
  return _internal_uitotal();
}
inline void Msg_LOG_BuyMB::_internal_set_uitotal(uint32_t value) {
  
  uitotal_ = value;
}
inline void Msg_LOG_BuyMB::set_uitotal(uint32_t value) {
  _internal_set_uitotal(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.uiTotal)
}

// uint32 uiId = 4;
inline void Msg_LOG_BuyMB::clear_uiid() {
  uiid_ = 0u;
}
inline uint32_t Msg_LOG_BuyMB::_internal_uiid() const {
  return uiid_;
}
inline uint32_t Msg_LOG_BuyMB::uiid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.uiId)
  return _internal_uiid();
}
inline void Msg_LOG_BuyMB::_internal_set_uiid(uint32_t value) {
  
  uiid_ = value;
}
inline void Msg_LOG_BuyMB::set_uiid(uint32_t value) {
  _internal_set_uiid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.uiId)
}

// int64 llOrderNum = 5;
inline void Msg_LOG_BuyMB::clear_llordernum() {
  llordernum_ = int64_t{0};
}
inline int64_t Msg_LOG_BuyMB::_internal_llordernum() const {
  return llordernum_;
}
inline int64_t Msg_LOG_BuyMB::llordernum() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.llOrderNum)
  return _internal_llordernum();
}
inline void Msg_LOG_BuyMB::_internal_set_llordernum(int64_t value) {
  
  llordernum_ = value;
}
inline void Msg_LOG_BuyMB::set_llordernum(int64_t value) {
  _internal_set_llordernum(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.llOrderNum)
}

// uint32 uiRmb = 6;
inline void Msg_LOG_BuyMB::clear_uirmb() {
  uirmb_ = 0u;
}
inline uint32_t Msg_LOG_BuyMB::_internal_uirmb() const {
  return uirmb_;
}
inline uint32_t Msg_LOG_BuyMB::uirmb() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.uiRmb)
  return _internal_uirmb();
}
inline void Msg_LOG_BuyMB::_internal_set_uirmb(uint32_t value) {
  
  uirmb_ = value;
}
inline void Msg_LOG_BuyMB::set_uirmb(uint32_t value) {
  _internal_set_uirmb(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.uiRmb)
}

// uint32 uiStatus = 7;
inline void Msg_LOG_BuyMB::clear_uistatus() {
  uistatus_ = 0u;
}
inline uint32_t Msg_LOG_BuyMB::_internal_uistatus() const {
  return uistatus_;
}
inline uint32_t Msg_LOG_BuyMB::uistatus() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.uiStatus)
  return _internal_uistatus();
}
inline void Msg_LOG_BuyMB::_internal_set_uistatus(uint32_t value) {
  
  uistatus_ = value;
}
inline void Msg_LOG_BuyMB::set_uistatus(uint32_t value) {
  _internal_set_uistatus(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.uiStatus)
}

// optional int64 llStart = 8;
inline bool Msg_LOG_BuyMB::_internal_has_llstart() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_LOG_BuyMB::has_llstart() const {
  return _internal_has_llstart();
}
inline void Msg_LOG_BuyMB::clear_llstart() {
  llstart_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Msg_LOG_BuyMB::_internal_llstart() const {
  return llstart_;
}
inline int64_t Msg_LOG_BuyMB::llstart() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.llStart)
  return _internal_llstart();
}
inline void Msg_LOG_BuyMB::_internal_set_llstart(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  llstart_ = value;
}
inline void Msg_LOG_BuyMB::set_llstart(int64_t value) {
  _internal_set_llstart(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.llStart)
}

// optional int64 llEnd = 9;
inline bool Msg_LOG_BuyMB::_internal_has_llend() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_LOG_BuyMB::has_llend() const {
  return _internal_has_llend();
}
inline void Msg_LOG_BuyMB::clear_llend() {
  llend_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t Msg_LOG_BuyMB::_internal_llend() const {
  return llend_;
}
inline int64_t Msg_LOG_BuyMB::llend() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyMB.llEnd)
  return _internal_llend();
}
inline void Msg_LOG_BuyMB::_internal_set_llend(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  llend_ = value;
}
inline void Msg_LOG_BuyMB::set_llend(int64_t value) {
  _internal_set_llend(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyMB.llEnd)
}

// -------------------------------------------------------------------

// Msg_LOG_BuyGP

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_BuyGP::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_BuyGP::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_BuyGP::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_BuyGP::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_BuyGP::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyGP.role)
  return _internal_role();
}
inline void Msg_LOG_BuyGP::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_BuyGP.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyGP::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyGP::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_BuyGP.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyGP::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_BuyGP::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_BuyGP.role)
  return _msg;
}
inline void Msg_LOG_BuyGP::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_BuyGP.role)
}

// uint32 uiSequence = 2;
inline void Msg_LOG_BuyGP::clear_uisequence() {
  uisequence_ = 0u;
}
inline uint32_t Msg_LOG_BuyGP::_internal_uisequence() const {
  return uisequence_;
}
inline uint32_t Msg_LOG_BuyGP::uisequence() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyGP.uiSequence)
  return _internal_uisequence();
}
inline void Msg_LOG_BuyGP::_internal_set_uisequence(uint32_t value) {
  
  uisequence_ = value;
}
inline void Msg_LOG_BuyGP::set_uisequence(uint32_t value) {
  _internal_set_uisequence(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyGP.uiSequence)
}

// uint32 uiGp = 3;
inline void Msg_LOG_BuyGP::clear_uigp() {
  uigp_ = 0u;
}
inline uint32_t Msg_LOG_BuyGP::_internal_uigp() const {
  return uigp_;
}
inline uint32_t Msg_LOG_BuyGP::uigp() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyGP.uiGp)
  return _internal_uigp();
}
inline void Msg_LOG_BuyGP::_internal_set_uigp(uint32_t value) {
  
  uigp_ = value;
}
inline void Msg_LOG_BuyGP::set_uigp(uint32_t value) {
  _internal_set_uigp(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyGP.uiGp)
}

// uint32 uiMb = 4;
inline void Msg_LOG_BuyGP::clear_uimb() {
  uimb_ = 0u;
}
inline uint32_t Msg_LOG_BuyGP::_internal_uimb() const {
  return uimb_;
}
inline uint32_t Msg_LOG_BuyGP::uimb() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyGP.uiMb)
  return _internal_uimb();
}
inline void Msg_LOG_BuyGP::_internal_set_uimb(uint32_t value) {
  
  uimb_ = value;
}
inline void Msg_LOG_BuyGP::set_uimb(uint32_t value) {
  _internal_set_uimb(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyGP.uiMb)
}

// uint32 uiCost = 5;
inline void Msg_LOG_BuyGP::clear_uicost() {
  uicost_ = 0u;
}
inline uint32_t Msg_LOG_BuyGP::_internal_uicost() const {
  return uicost_;
}
inline uint32_t Msg_LOG_BuyGP::uicost() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_BuyGP.uiCost)
  return _internal_uicost();
}
inline void Msg_LOG_BuyGP::_internal_set_uicost(uint32_t value) {
  
  uicost_ = value;
}
inline void Msg_LOG_BuyGP::set_uicost(uint32_t value) {
  _internal_set_uicost(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_BuyGP.uiCost)
}

// -------------------------------------------------------------------

// Msg_Log_RecordOnline

// uint32 areanno = 1;
inline void Msg_Log_RecordOnline::clear_areanno() {
  areanno_ = 0u;
}
inline uint32_t Msg_Log_RecordOnline::_internal_areanno() const {
  return areanno_;
}
inline uint32_t Msg_Log_RecordOnline::areanno() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_RecordOnline.areanno)
  return _internal_areanno();
}
inline void Msg_Log_RecordOnline::_internal_set_areanno(uint32_t value) {
  
  areanno_ = value;
}
inline void Msg_Log_RecordOnline::set_areanno(uint32_t value) {
  _internal_set_areanno(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_RecordOnline.areanno)
}

// optional uint32 online_num = 2;
inline bool Msg_Log_RecordOnline::_internal_has_online_num() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_Log_RecordOnline::has_online_num() const {
  return _internal_has_online_num();
}
inline void Msg_Log_RecordOnline::clear_online_num() {
  online_num_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Msg_Log_RecordOnline::_internal_online_num() const {
  return online_num_;
}
inline uint32_t Msg_Log_RecordOnline::online_num() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_RecordOnline.online_num)
  return _internal_online_num();
}
inline void Msg_Log_RecordOnline::_internal_set_online_num(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  online_num_ = value;
}
inline void Msg_Log_RecordOnline::set_online_num(uint32_t value) {
  _internal_set_online_num(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_RecordOnline.online_num)
}

// optional int64 time = 3;
inline bool Msg_Log_RecordOnline::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_Log_RecordOnline::has_time() const {
  return _internal_has_time();
}
inline void Msg_Log_RecordOnline::clear_time() {
  time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t Msg_Log_RecordOnline::_internal_time() const {
  return time_;
}
inline int64_t Msg_Log_RecordOnline::time() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_RecordOnline.time)
  return _internal_time();
}
inline void Msg_Log_RecordOnline::_internal_set_time(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
}
inline void Msg_Log_RecordOnline::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_RecordOnline.time)
}

// optional uint32 platid = 4;
inline bool Msg_Log_RecordOnline::_internal_has_platid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_Log_RecordOnline::has_platid() const {
  return _internal_has_platid();
}
inline void Msg_Log_RecordOnline::clear_platid() {
  platid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Msg_Log_RecordOnline::_internal_platid() const {
  return platid_;
}
inline uint32_t Msg_Log_RecordOnline::platid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_RecordOnline.platid)
  return _internal_platid();
}
inline void Msg_Log_RecordOnline::_internal_set_platid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  platid_ = value;
}
inline void Msg_Log_RecordOnline::set_platid(uint32_t value) {
  _internal_set_platid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_RecordOnline.platid)
}

// -------------------------------------------------------------------

// Msg_Log_CreateRole

// .XrPb.LogRoleBase role = 1;
inline bool Msg_Log_CreateRole::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_Log_CreateRole::has_role() const {
  return _internal_has_role();
}
inline void Msg_Log_CreateRole::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_Log_CreateRole::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_Log_CreateRole::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_CreateRole.role)
  return _internal_role();
}
inline void Msg_Log_CreateRole::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_Log_CreateRole.role)
}
inline ::XrPb::LogRoleBase* Msg_Log_CreateRole::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_Log_CreateRole::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_CreateRole.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_Log_CreateRole::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_Log_CreateRole::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_CreateRole.role)
  return _msg;
}
inline void Msg_Log_CreateRole::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_CreateRole.role)
}

// string rolename = 2;
inline void Msg_Log_CreateRole::clear_rolename() {
  rolename_.ClearToEmpty();
}
inline const std::string& Msg_Log_CreateRole::rolename() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_CreateRole.rolename)
  return _internal_rolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_Log_CreateRole::set_rolename(ArgT0&& arg0, ArgT... args) {
 
 rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_CreateRole.rolename)
}
inline std::string* Msg_Log_CreateRole::mutable_rolename() {
  std::string* _s = _internal_mutable_rolename();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_CreateRole.rolename)
  return _s;
}
inline const std::string& Msg_Log_CreateRole::_internal_rolename() const {
  return rolename_.Get();
}
inline void Msg_Log_CreateRole::_internal_set_rolename(const std::string& value) {
  
  rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_Log_CreateRole::_internal_mutable_rolename() {
  
  return rolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_Log_CreateRole::release_rolename() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_CreateRole.rolename)
  return rolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Msg_Log_CreateRole::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_CreateRole.rolename)
}

// -------------------------------------------------------------------

// Msg_Log_ModifyRoleName

// .XrPb.LogRoleBase role = 1;
inline bool Msg_Log_ModifyRoleName::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_Log_ModifyRoleName::has_role() const {
  return _internal_has_role();
}
inline void Msg_Log_ModifyRoleName::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_Log_ModifyRoleName::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_Log_ModifyRoleName::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_ModifyRoleName.role)
  return _internal_role();
}
inline void Msg_Log_ModifyRoleName::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_Log_ModifyRoleName.role)
}
inline ::XrPb::LogRoleBase* Msg_Log_ModifyRoleName::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_Log_ModifyRoleName::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_ModifyRoleName.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_Log_ModifyRoleName::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_Log_ModifyRoleName::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_ModifyRoleName.role)
  return _msg;
}
inline void Msg_Log_ModifyRoleName::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_ModifyRoleName.role)
}

// string rolename = 2;
inline void Msg_Log_ModifyRoleName::clear_rolename() {
  rolename_.ClearToEmpty();
}
inline const std::string& Msg_Log_ModifyRoleName::rolename() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_ModifyRoleName.rolename)
  return _internal_rolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_Log_ModifyRoleName::set_rolename(ArgT0&& arg0, ArgT... args) {
 
 rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_ModifyRoleName.rolename)
}
inline std::string* Msg_Log_ModifyRoleName::mutable_rolename() {
  std::string* _s = _internal_mutable_rolename();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_ModifyRoleName.rolename)
  return _s;
}
inline const std::string& Msg_Log_ModifyRoleName::_internal_rolename() const {
  return rolename_.Get();
}
inline void Msg_Log_ModifyRoleName::_internal_set_rolename(const std::string& value) {
  
  rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_Log_ModifyRoleName::_internal_mutable_rolename() {
  
  return rolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_Log_ModifyRoleName::release_rolename() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_ModifyRoleName.rolename)
  return rolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Msg_Log_ModifyRoleName::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_ModifyRoleName.rolename)
}

// string old_rolename = 3;
inline void Msg_Log_ModifyRoleName::clear_old_rolename() {
  old_rolename_.ClearToEmpty();
}
inline const std::string& Msg_Log_ModifyRoleName::old_rolename() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_Log_ModifyRoleName.old_rolename)
  return _internal_old_rolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_Log_ModifyRoleName::set_old_rolename(ArgT0&& arg0, ArgT... args) {
 
 old_rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_Log_ModifyRoleName.old_rolename)
}
inline std::string* Msg_Log_ModifyRoleName::mutable_old_rolename() {
  std::string* _s = _internal_mutable_old_rolename();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_Log_ModifyRoleName.old_rolename)
  return _s;
}
inline const std::string& Msg_Log_ModifyRoleName::_internal_old_rolename() const {
  return old_rolename_.Get();
}
inline void Msg_Log_ModifyRoleName::_internal_set_old_rolename(const std::string& value) {
  
  old_rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_Log_ModifyRoleName::_internal_mutable_old_rolename() {
  
  return old_rolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_Log_ModifyRoleName::release_old_rolename() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_Log_ModifyRoleName.old_rolename)
  return old_rolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Msg_Log_ModifyRoleName::set_allocated_old_rolename(std::string* old_rolename) {
  if (old_rolename != nullptr) {
    
  } else {
    
  }
  old_rolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_rolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (old_rolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    old_rolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_Log_ModifyRoleName.old_rolename)
}

// -------------------------------------------------------------------

// Msg_LOG_RoleChatMsg

// .XrPb.LogRoleBase role = 1;
inline bool Msg_LOG_RoleChatMsg::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_LOG_RoleChatMsg::has_role() const {
  return _internal_has_role();
}
inline void Msg_LOG_RoleChatMsg::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleChatMsg::_internal_role() const {
  const ::XrPb::LogRoleBase* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::LogRoleBase&>(
      ::XrPb::_LogRoleBase_default_instance_);
}
inline const ::XrPb::LogRoleBase& Msg_LOG_RoleChatMsg::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleChatMsg.role)
  return _internal_role();
}
inline void Msg_LOG_RoleChatMsg::unsafe_arena_set_allocated_role(
    ::XrPb::LogRoleBase* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_LOG_RoleChatMsg.role)
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleChatMsg::release_role() {
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleChatMsg::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleChatMsg.role)
  
  ::XrPb::LogRoleBase* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleChatMsg::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::LogRoleBase>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::LogRoleBase* Msg_LOG_RoleChatMsg::mutable_role() {
  ::XrPb::LogRoleBase* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleChatMsg.role)
  return _msg;
}
inline void Msg_LOG_RoleChatMsg::set_allocated_role(::XrPb::LogRoleBase* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::LogRoleBase>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleChatMsg.role)
}

// .XrPb.EChatType type = 2;
inline void Msg_LOG_RoleChatMsg::clear_type() {
  type_ = 0;
}
inline ::XrPb::EChatType Msg_LOG_RoleChatMsg::_internal_type() const {
  return static_cast< ::XrPb::EChatType >(type_);
}
inline ::XrPb::EChatType Msg_LOG_RoleChatMsg::type() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleChatMsg.type)
  return _internal_type();
}
inline void Msg_LOG_RoleChatMsg::_internal_set_type(::XrPb::EChatType value) {
  
  type_ = value;
}
inline void Msg_LOG_RoleChatMsg::set_type(::XrPb::EChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleChatMsg.type)
}

// string msg = 3;
inline void Msg_LOG_RoleChatMsg::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& Msg_LOG_RoleChatMsg::msg() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_LOG_RoleChatMsg.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_LOG_RoleChatMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_LOG_RoleChatMsg.msg)
}
inline std::string* Msg_LOG_RoleChatMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_LOG_RoleChatMsg.msg)
  return _s;
}
inline const std::string& Msg_LOG_RoleChatMsg::_internal_msg() const {
  return msg_.Get();
}
inline void Msg_LOG_RoleChatMsg::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_LOG_RoleChatMsg::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_LOG_RoleChatMsg::release_msg() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_LOG_RoleChatMsg.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Msg_LOG_RoleChatMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_LOG_RoleChatMsg.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XrPb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XrPb::MsgSvrMod_Log_MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::MsgSvrMod_Log_MsgId>() {
  return ::XrPb::MsgSvrMod_Log_MsgId_descriptor();
}
template <> struct is_proto_enum< ::XrPb::EFromType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::EFromType>() {
  return ::XrPb::EFromType_descriptor();
}
template <> struct is_proto_enum< ::XrPb::EToType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::EToType>() {
  return ::XrPb::EToType_descriptor();
}
template <> struct is_proto_enum< ::XrPb::ELogProgressType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::ELogProgressType>() {
  return ::XrPb::ELogProgressType_descriptor();
}
template <> struct is_proto_enum< ::XrPb::ELogAttrType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::ELogAttrType>() {
  return ::XrPb::ELogAttrType_descriptor();
}
template <> struct is_proto_enum< ::XrPb::ELogFriendType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::ELogFriendType>() {
  return ::XrPb::ELogFriendType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2fMsgLog_2eproto
