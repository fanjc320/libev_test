// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server/MsgSvrCommon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2fMsgSvrCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2fMsgSvrCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client/Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2fMsgSvrCommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2fMsgSvrCommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2fMsgSvrCommon_2eproto;
namespace XrPb {
class Msg_SS_SvrReg_CS;
struct Msg_SS_SvrReg_CSDefaultTypeInternal;
extern Msg_SS_SvrReg_CSDefaultTypeInternal _Msg_SS_SvrReg_CS_default_instance_;
class Msg_SS_SvrReg_SC;
struct Msg_SS_SvrReg_SCDefaultTypeInternal;
extern Msg_SS_SvrReg_SCDefaultTypeInternal _Msg_SS_SvrReg_SC_default_instance_;
class Msg_SS_TransData;
struct Msg_SS_TransDataDefaultTypeInternal;
extern Msg_SS_TransDataDefaultTypeInternal _Msg_SS_TransData_default_instance_;
class Msg_SS_UpdateAccData;
struct Msg_SS_UpdateAccDataDefaultTypeInternal;
extern Msg_SS_UpdateAccDataDefaultTypeInternal _Msg_SS_UpdateAccData_default_instance_;
class Msg_SS_UpdateRoleStatus;
struct Msg_SS_UpdateRoleStatusDefaultTypeInternal;
extern Msg_SS_UpdateRoleStatusDefaultTypeInternal _Msg_SS_UpdateRoleStatus_default_instance_;
class Msg_SvrCommon;
struct Msg_SvrCommonDefaultTypeInternal;
extern Msg_SvrCommonDefaultTypeInternal _Msg_SvrCommon_default_instance_;
class RoleFormInfo;
struct RoleFormInfoDefaultTypeInternal;
extern RoleFormInfoDefaultTypeInternal _RoleFormInfo_default_instance_;
class RoleOnLineStatus;
struct RoleOnLineStatusDefaultTypeInternal;
extern RoleOnLineStatusDefaultTypeInternal _RoleOnLineStatus_default_instance_;
class SvrMod_Com;
struct SvrMod_ComDefaultTypeInternal;
extern SvrMod_ComDefaultTypeInternal _SvrMod_Com_default_instance_;
class Svr_Role_Info;
struct Svr_Role_InfoDefaultTypeInternal;
extern Svr_Role_InfoDefaultTypeInternal _Svr_Role_Info_default_instance_;
}  // namespace XrPb
PROTOBUF_NAMESPACE_OPEN
template<> ::XrPb::Msg_SS_SvrReg_CS* Arena::CreateMaybeMessage<::XrPb::Msg_SS_SvrReg_CS>(Arena*);
template<> ::XrPb::Msg_SS_SvrReg_SC* Arena::CreateMaybeMessage<::XrPb::Msg_SS_SvrReg_SC>(Arena*);
template<> ::XrPb::Msg_SS_TransData* Arena::CreateMaybeMessage<::XrPb::Msg_SS_TransData>(Arena*);
template<> ::XrPb::Msg_SS_UpdateAccData* Arena::CreateMaybeMessage<::XrPb::Msg_SS_UpdateAccData>(Arena*);
template<> ::XrPb::Msg_SS_UpdateRoleStatus* Arena::CreateMaybeMessage<::XrPb::Msg_SS_UpdateRoleStatus>(Arena*);
template<> ::XrPb::Msg_SvrCommon* Arena::CreateMaybeMessage<::XrPb::Msg_SvrCommon>(Arena*);
template<> ::XrPb::RoleFormInfo* Arena::CreateMaybeMessage<::XrPb::RoleFormInfo>(Arena*);
template<> ::XrPb::RoleOnLineStatus* Arena::CreateMaybeMessage<::XrPb::RoleOnLineStatus>(Arena*);
template<> ::XrPb::SvrMod_Com* Arena::CreateMaybeMessage<::XrPb::SvrMod_Com>(Arena*);
template<> ::XrPb::Svr_Role_Info* Arena::CreateMaybeMessage<::XrPb::Svr_Role_Info>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XrPb {

enum SvrMod_Com_MsgId : int {
  SvrMod_Com_MsgId_ServerModuleNone = 0,
  SvrMod_Com_MsgId_ServerModuleBegin = 100,
  SvrMod_Com_MsgId_SvrInner = 101,
  SvrMod_Com_MsgId_ServerModuleEnd = 199,
  SvrMod_Com_MsgId_SvrMod_Com_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SvrMod_Com_MsgId_SvrMod_Com_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SvrMod_Com_MsgId_IsValid(int value);
constexpr SvrMod_Com_MsgId SvrMod_Com_MsgId_MsgId_MIN = SvrMod_Com_MsgId_ServerModuleNone;
constexpr SvrMod_Com_MsgId SvrMod_Com_MsgId_MsgId_MAX = SvrMod_Com_MsgId_ServerModuleEnd;
constexpr int SvrMod_Com_MsgId_MsgId_ARRAYSIZE = SvrMod_Com_MsgId_MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SvrMod_Com_MsgId_descriptor();
template<typename T>
inline const std::string& SvrMod_Com_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SvrMod_Com_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SvrMod_Com_MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SvrMod_Com_MsgId_descriptor(), enum_t_value);
}
inline bool SvrMod_Com_MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SvrMod_Com_MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SvrMod_Com_MsgId>(
    SvrMod_Com_MsgId_descriptor(), name, value);
}
enum Msg_SvrCommon_MsgId : int {
  Msg_SvrCommon_MsgId_MSG_SS_NONE = 0,
  Msg_SvrCommon_MsgId_Msg_SS_SvrReg_CS = 1,
  Msg_SvrCommon_MsgId_Msg_SS_SvrReg_SC = 2,
  Msg_SvrCommon_MsgId_Msg_SS_TransData = 3,
  Msg_SvrCommon_MsgId_Msg_SS_UpdateAccData = 4,
  Msg_SvrCommon_MsgId_Msg_SS_UpdateRoleStatus = 5,
  Msg_SvrCommon_MsgId_Msg_SvrCommon_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Msg_SvrCommon_MsgId_Msg_SvrCommon_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Msg_SvrCommon_MsgId_IsValid(int value);
constexpr Msg_SvrCommon_MsgId Msg_SvrCommon_MsgId_MsgId_MIN = Msg_SvrCommon_MsgId_MSG_SS_NONE;
constexpr Msg_SvrCommon_MsgId Msg_SvrCommon_MsgId_MsgId_MAX = Msg_SvrCommon_MsgId_Msg_SS_UpdateRoleStatus;
constexpr int Msg_SvrCommon_MsgId_MsgId_ARRAYSIZE = Msg_SvrCommon_MsgId_MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Msg_SvrCommon_MsgId_descriptor();
template<typename T>
inline const std::string& Msg_SvrCommon_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Msg_SvrCommon_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Msg_SvrCommon_MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Msg_SvrCommon_MsgId_descriptor(), enum_t_value);
}
inline bool Msg_SvrCommon_MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Msg_SvrCommon_MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Msg_SvrCommon_MsgId>(
    Msg_SvrCommon_MsgId_descriptor(), name, value);
}
// ===================================================================

class SvrMod_Com final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:XrPb.SvrMod_Com) */ {
 public:
  inline SvrMod_Com() : SvrMod_Com(nullptr) {}
  explicit constexpr SvrMod_Com(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SvrMod_Com(const SvrMod_Com& from);
  SvrMod_Com(SvrMod_Com&& from) noexcept
    : SvrMod_Com() {
    *this = ::std::move(from);
  }

  inline SvrMod_Com& operator=(const SvrMod_Com& from) {
    CopyFrom(from);
    return *this;
  }
  inline SvrMod_Com& operator=(SvrMod_Com&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SvrMod_Com& default_instance() {
    return *internal_default_instance();
  }
  static inline const SvrMod_Com* internal_default_instance() {
    return reinterpret_cast<const SvrMod_Com*>(
               &_SvrMod_Com_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SvrMod_Com& a, SvrMod_Com& b) {
    a.Swap(&b);
  }
  inline void Swap(SvrMod_Com* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SvrMod_Com* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SvrMod_Com* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SvrMod_Com>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SvrMod_Com& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SvrMod_Com& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.SvrMod_Com";
  }
  protected:
  explicit SvrMod_Com(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SvrMod_Com_MsgId MsgId;
  static constexpr MsgId ServerModuleNone =
    SvrMod_Com_MsgId_ServerModuleNone;
  static constexpr MsgId ServerModuleBegin =
    SvrMod_Com_MsgId_ServerModuleBegin;
  static constexpr MsgId SvrInner =
    SvrMod_Com_MsgId_SvrInner;
  static constexpr MsgId ServerModuleEnd =
    SvrMod_Com_MsgId_ServerModuleEnd;
  static inline bool MsgId_IsValid(int value) {
    return SvrMod_Com_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    SvrMod_Com_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    SvrMod_Com_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    SvrMod_Com_MsgId_MsgId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgId_descriptor() {
    return SvrMod_Com_MsgId_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return SvrMod_Com_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgId* value) {
    return SvrMod_Com_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:XrPb.SvrMod_Com)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class RoleFormInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.RoleFormInfo) */ {
 public:
  inline RoleFormInfo() : RoleFormInfo(nullptr) {}
  ~RoleFormInfo() override;
  explicit constexpr RoleFormInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleFormInfo(const RoleFormInfo& from);
  RoleFormInfo(RoleFormInfo&& from) noexcept
    : RoleFormInfo() {
    *this = ::std::move(from);
  }

  inline RoleFormInfo& operator=(const RoleFormInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleFormInfo& operator=(RoleFormInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleFormInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleFormInfo* internal_default_instance() {
    return reinterpret_cast<const RoleFormInfo*>(
               &_RoleFormInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoleFormInfo& a, RoleFormInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleFormInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleFormInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleFormInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleFormInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleFormInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleFormInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleFormInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.RoleFormInfo";
  }
  protected:
  explicit RoleFormInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.RoleFormInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SvrCommon final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:XrPb.Msg_SvrCommon) */ {
 public:
  inline Msg_SvrCommon() : Msg_SvrCommon(nullptr) {}
  explicit constexpr Msg_SvrCommon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SvrCommon(const Msg_SvrCommon& from);
  Msg_SvrCommon(Msg_SvrCommon&& from) noexcept
    : Msg_SvrCommon() {
    *this = ::std::move(from);
  }

  inline Msg_SvrCommon& operator=(const Msg_SvrCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SvrCommon& operator=(Msg_SvrCommon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SvrCommon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SvrCommon* internal_default_instance() {
    return reinterpret_cast<const Msg_SvrCommon*>(
               &_Msg_SvrCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Msg_SvrCommon& a, Msg_SvrCommon& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SvrCommon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SvrCommon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SvrCommon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SvrCommon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Msg_SvrCommon& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Msg_SvrCommon& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SvrCommon";
  }
  protected:
  explicit Msg_SvrCommon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Msg_SvrCommon_MsgId MsgId;
  static constexpr MsgId MSG_SS_NONE =
    Msg_SvrCommon_MsgId_MSG_SS_NONE;
  static constexpr MsgId Msg_SS_SvrReg_CS =
    Msg_SvrCommon_MsgId_Msg_SS_SvrReg_CS;
  static constexpr MsgId Msg_SS_SvrReg_SC =
    Msg_SvrCommon_MsgId_Msg_SS_SvrReg_SC;
  static constexpr MsgId Msg_SS_TransData =
    Msg_SvrCommon_MsgId_Msg_SS_TransData;
  static constexpr MsgId Msg_SS_UpdateAccData =
    Msg_SvrCommon_MsgId_Msg_SS_UpdateAccData;
  static constexpr MsgId Msg_SS_UpdateRoleStatus =
    Msg_SvrCommon_MsgId_Msg_SS_UpdateRoleStatus;
  static inline bool MsgId_IsValid(int value) {
    return Msg_SvrCommon_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    Msg_SvrCommon_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    Msg_SvrCommon_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    Msg_SvrCommon_MsgId_MsgId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgId_descriptor() {
    return Msg_SvrCommon_MsgId_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return Msg_SvrCommon_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgId* value) {
    return Msg_SvrCommon_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SvrCommon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SS_SvrReg_CS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_SS_SvrReg_CS) */ {
 public:
  inline Msg_SS_SvrReg_CS() : Msg_SS_SvrReg_CS(nullptr) {}
  ~Msg_SS_SvrReg_CS() override;
  explicit constexpr Msg_SS_SvrReg_CS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SS_SvrReg_CS(const Msg_SS_SvrReg_CS& from);
  Msg_SS_SvrReg_CS(Msg_SS_SvrReg_CS&& from) noexcept
    : Msg_SS_SvrReg_CS() {
    *this = ::std::move(from);
  }

  inline Msg_SS_SvrReg_CS& operator=(const Msg_SS_SvrReg_CS& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SS_SvrReg_CS& operator=(Msg_SS_SvrReg_CS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SS_SvrReg_CS& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SS_SvrReg_CS* internal_default_instance() {
    return reinterpret_cast<const Msg_SS_SvrReg_CS*>(
               &_Msg_SS_SvrReg_CS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Msg_SS_SvrReg_CS& a, Msg_SS_SvrReg_CS& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SS_SvrReg_CS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SS_SvrReg_CS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SS_SvrReg_CS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SS_SvrReg_CS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_SS_SvrReg_CS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_SS_SvrReg_CS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_SS_SvrReg_CS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SS_SvrReg_CS";
  }
  protected:
  explicit Msg_SS_SvrReg_CS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUiServerKindFieldNumber = 1,
    kUiServerIdFieldNumber = 2,
    kPlatidFieldNumber = 3,
    kIndexFieldNumber = 4,
    kAreanoFieldNumber = 5,
  };
  // optional uint32 uiServerKind = 1;
  bool has_uiserverkind() const;
  private:
  bool _internal_has_uiserverkind() const;
  public:
  void clear_uiserverkind();
  uint32_t uiserverkind() const;
  void set_uiserverkind(uint32_t value);
  private:
  uint32_t _internal_uiserverkind() const;
  void _internal_set_uiserverkind(uint32_t value);
  public:

  // optional uint32 uiServerId = 2;
  bool has_uiserverid() const;
  private:
  bool _internal_has_uiserverid() const;
  public:
  void clear_uiserverid();
  uint32_t uiserverid() const;
  void set_uiserverid(uint32_t value);
  private:
  uint32_t _internal_uiserverid() const;
  void _internal_set_uiserverid(uint32_t value);
  public:

  // optional uint32 platid = 3;
  bool has_platid() const;
  private:
  bool _internal_has_platid() const;
  public:
  void clear_platid();
  uint32_t platid() const;
  void set_platid(uint32_t value);
  private:
  uint32_t _internal_platid() const;
  void _internal_set_platid(uint32_t value);
  public:

  // optional uint32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // optional uint32 areano = 5;
  bool has_areano() const;
  private:
  bool _internal_has_areano() const;
  public:
  void clear_areano();
  uint32_t areano() const;
  void set_areano(uint32_t value);
  private:
  uint32_t _internal_areano() const;
  void _internal_set_areano(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SS_SvrReg_CS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t uiserverkind_;
  uint32_t uiserverid_;
  uint32_t platid_;
  uint32_t index_;
  uint32_t areano_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SS_SvrReg_SC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_SS_SvrReg_SC) */ {
 public:
  inline Msg_SS_SvrReg_SC() : Msg_SS_SvrReg_SC(nullptr) {}
  ~Msg_SS_SvrReg_SC() override;
  explicit constexpr Msg_SS_SvrReg_SC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SS_SvrReg_SC(const Msg_SS_SvrReg_SC& from);
  Msg_SS_SvrReg_SC(Msg_SS_SvrReg_SC&& from) noexcept
    : Msg_SS_SvrReg_SC() {
    *this = ::std::move(from);
  }

  inline Msg_SS_SvrReg_SC& operator=(const Msg_SS_SvrReg_SC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SS_SvrReg_SC& operator=(Msg_SS_SvrReg_SC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SS_SvrReg_SC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SS_SvrReg_SC* internal_default_instance() {
    return reinterpret_cast<const Msg_SS_SvrReg_SC*>(
               &_Msg_SS_SvrReg_SC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Msg_SS_SvrReg_SC& a, Msg_SS_SvrReg_SC& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SS_SvrReg_SC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SS_SvrReg_SC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SS_SvrReg_SC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SS_SvrReg_SC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_SS_SvrReg_SC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_SS_SvrReg_SC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_SS_SvrReg_SC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SS_SvrReg_SC";
  }
  protected:
  explicit Msg_SS_SvrReg_SC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUiServerKindFieldNumber = 1,
    kUiServerIdFieldNumber = 2,
  };
  // optional uint32 uiServerKind = 1;
  bool has_uiserverkind() const;
  private:
  bool _internal_has_uiserverkind() const;
  public:
  void clear_uiserverkind();
  uint32_t uiserverkind() const;
  void set_uiserverkind(uint32_t value);
  private:
  uint32_t _internal_uiserverkind() const;
  void _internal_set_uiserverkind(uint32_t value);
  public:

  // optional uint32 uiServerId = 2;
  bool has_uiserverid() const;
  private:
  bool _internal_has_uiserverid() const;
  public:
  void clear_uiserverid();
  uint32_t uiserverid() const;
  void set_uiserverid(uint32_t value);
  private:
  uint32_t _internal_uiserverid() const;
  void _internal_set_uiserverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SS_SvrReg_SC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t uiserverkind_;
  uint32_t uiserverid_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SS_TransData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_SS_TransData) */ {
 public:
  inline Msg_SS_TransData() : Msg_SS_TransData(nullptr) {}
  ~Msg_SS_TransData() override;
  explicit constexpr Msg_SS_TransData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SS_TransData(const Msg_SS_TransData& from);
  Msg_SS_TransData(Msg_SS_TransData&& from) noexcept
    : Msg_SS_TransData() {
    *this = ::std::move(from);
  }

  inline Msg_SS_TransData& operator=(const Msg_SS_TransData& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SS_TransData& operator=(Msg_SS_TransData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SS_TransData& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SS_TransData* internal_default_instance() {
    return reinterpret_cast<const Msg_SS_TransData*>(
               &_Msg_SS_TransData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Msg_SS_TransData& a, Msg_SS_TransData& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SS_TransData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SS_TransData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SS_TransData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SS_TransData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_SS_TransData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_SS_TransData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_SS_TransData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SS_TransData";
  }
  protected:
  explicit Msg_SS_TransData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccLstFieldNumber = 2,
    kProtoMsgFieldNumber = 3,
    kSeqIdFieldNumber = 1,
    kModIdFieldNumber = 4,
    kProtoIdFieldNumber = 5,
    kRetCodeFieldNumber = 6,
  };
  // repeated int64 acc_lst = 2;
  int acc_lst_size() const;
  private:
  int _internal_acc_lst_size() const;
  public:
  void clear_acc_lst();
  private:
  int64_t _internal_acc_lst(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_acc_lst() const;
  void _internal_add_acc_lst(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_acc_lst();
  public:
  int64_t acc_lst(int index) const;
  void set_acc_lst(int index, int64_t value);
  void add_acc_lst(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      acc_lst() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_acc_lst();

  // optional bytes proto_msg = 3;
  bool has_proto_msg() const;
  private:
  bool _internal_has_proto_msg() const;
  public:
  void clear_proto_msg();
  const std::string& proto_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proto_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proto_msg();
  PROTOBUF_NODISCARD std::string* release_proto_msg();
  void set_allocated_proto_msg(std::string* proto_msg);
  private:
  const std::string& _internal_proto_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proto_msg(const std::string& value);
  std::string* _internal_mutable_proto_msg();
  public:

  // optional uint32 seq_id = 1;
  bool has_seq_id() const;
  private:
  bool _internal_has_seq_id() const;
  public:
  void clear_seq_id();
  uint32_t seq_id() const;
  void set_seq_id(uint32_t value);
  private:
  uint32_t _internal_seq_id() const;
  void _internal_set_seq_id(uint32_t value);
  public:

  // optional uint32 mod_id = 4;
  bool has_mod_id() const;
  private:
  bool _internal_has_mod_id() const;
  public:
  void clear_mod_id();
  uint32_t mod_id() const;
  void set_mod_id(uint32_t value);
  private:
  uint32_t _internal_mod_id() const;
  void _internal_set_mod_id(uint32_t value);
  public:

  // optional uint32 proto_id = 5;
  bool has_proto_id() const;
  private:
  bool _internal_has_proto_id() const;
  public:
  void clear_proto_id();
  uint32_t proto_id() const;
  void set_proto_id(uint32_t value);
  private:
  uint32_t _internal_proto_id() const;
  void _internal_set_proto_id(uint32_t value);
  public:

  // optional int32 ret_code = 6;
  bool has_ret_code() const;
  private:
  bool _internal_has_ret_code() const;
  public:
  void clear_ret_code();
  int32_t ret_code() const;
  void set_ret_code(int32_t value);
  private:
  int32_t _internal_ret_code() const;
  void _internal_set_ret_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SS_TransData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > acc_lst_;
  mutable std::atomic<int> _acc_lst_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_msg_;
  uint32_t seq_id_;
  uint32_t mod_id_;
  uint32_t proto_id_;
  int32_t ret_code_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Svr_Role_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Svr_Role_Info) */ {
 public:
  inline Svr_Role_Info() : Svr_Role_Info(nullptr) {}
  ~Svr_Role_Info() override;
  explicit constexpr Svr_Role_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Svr_Role_Info(const Svr_Role_Info& from);
  Svr_Role_Info(Svr_Role_Info&& from) noexcept
    : Svr_Role_Info() {
    *this = ::std::move(from);
  }

  inline Svr_Role_Info& operator=(const Svr_Role_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Svr_Role_Info& operator=(Svr_Role_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Svr_Role_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Svr_Role_Info* internal_default_instance() {
    return reinterpret_cast<const Svr_Role_Info*>(
               &_Svr_Role_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Svr_Role_Info& a, Svr_Role_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Svr_Role_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Svr_Role_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Svr_Role_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Svr_Role_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Svr_Role_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Svr_Role_Info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Svr_Role_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Svr_Role_Info";
  }
  protected:
  explicit Svr_Role_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleNameFieldNumber = 2,
    kFormFieldNumber = 4,
    kAccIdFieldNumber = 1,
    kLevelFieldNumber = 3,
    kGenderFieldNumber = 5,
    kLogoutTimeFieldNumber = 7,
    kPlayerStatusFieldNumber = 6,
    kGameIdFieldNumber = 8,
    kGateIdFieldNumber = 9,
  };
  // optional string role_name = 2;
  bool has_role_name() const;
  private:
  bool _internal_has_role_name() const;
  public:
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // optional .XrPb.FormData form = 4;
  bool has_form() const;
  private:
  bool _internal_has_form() const;
  public:
  void clear_form();
  const ::XrPb::FormData& form() const;
  PROTOBUF_NODISCARD ::XrPb::FormData* release_form();
  ::XrPb::FormData* mutable_form();
  void set_allocated_form(::XrPb::FormData* form);
  private:
  const ::XrPb::FormData& _internal_form() const;
  ::XrPb::FormData* _internal_mutable_form();
  public:
  void unsafe_arena_set_allocated_form(
      ::XrPb::FormData* form);
  ::XrPb::FormData* unsafe_arena_release_form();

  // optional int64 acc_id = 1;
  bool has_acc_id() const;
  private:
  bool _internal_has_acc_id() const;
  public:
  void clear_acc_id();
  int64_t acc_id() const;
  void set_acc_id(int64_t value);
  private:
  int64_t _internal_acc_id() const;
  void _internal_set_acc_id(int64_t value);
  public:

  // optional uint32 level = 3;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // optional uint32 gender = 5;
  bool has_gender() const;
  private:
  bool _internal_has_gender() const;
  public:
  void clear_gender();
  uint32_t gender() const;
  void set_gender(uint32_t value);
  private:
  uint32_t _internal_gender() const;
  void _internal_set_gender(uint32_t value);
  public:

  // optional int64 logout_time = 7;
  bool has_logout_time() const;
  private:
  bool _internal_has_logout_time() const;
  public:
  void clear_logout_time();
  int64_t logout_time() const;
  void set_logout_time(int64_t value);
  private:
  int64_t _internal_logout_time() const;
  void _internal_set_logout_time(int64_t value);
  public:

  // optional .XrPb.PlayerStatus player_status = 6;
  bool has_player_status() const;
  private:
  bool _internal_has_player_status() const;
  public:
  void clear_player_status();
  ::XrPb::PlayerStatus player_status() const;
  void set_player_status(::XrPb::PlayerStatus value);
  private:
  ::XrPb::PlayerStatus _internal_player_status() const;
  void _internal_set_player_status(::XrPb::PlayerStatus value);
  public:

  // optional uint32 game_id = 8;
  bool has_game_id() const;
  private:
  bool _internal_has_game_id() const;
  public:
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // optional uint32 gate_id = 9;
  bool has_gate_id() const;
  private:
  bool _internal_has_gate_id() const;
  public:
  void clear_gate_id();
  uint32_t gate_id() const;
  void set_gate_id(uint32_t value);
  private:
  uint32_t _internal_gate_id() const;
  void _internal_set_gate_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.Svr_Role_Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
  ::XrPb::FormData* form_;
  int64_t acc_id_;
  uint32_t level_;
  uint32_t gender_;
  int64_t logout_time_;
  int player_status_;
  uint32_t game_id_;
  uint32_t gate_id_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SS_UpdateAccData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_SS_UpdateAccData) */ {
 public:
  inline Msg_SS_UpdateAccData() : Msg_SS_UpdateAccData(nullptr) {}
  ~Msg_SS_UpdateAccData() override;
  explicit constexpr Msg_SS_UpdateAccData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SS_UpdateAccData(const Msg_SS_UpdateAccData& from);
  Msg_SS_UpdateAccData(Msg_SS_UpdateAccData&& from) noexcept
    : Msg_SS_UpdateAccData() {
    *this = ::std::move(from);
  }

  inline Msg_SS_UpdateAccData& operator=(const Msg_SS_UpdateAccData& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SS_UpdateAccData& operator=(Msg_SS_UpdateAccData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SS_UpdateAccData& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SS_UpdateAccData* internal_default_instance() {
    return reinterpret_cast<const Msg_SS_UpdateAccData*>(
               &_Msg_SS_UpdateAccData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Msg_SS_UpdateAccData& a, Msg_SS_UpdateAccData& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SS_UpdateAccData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SS_UpdateAccData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SS_UpdateAccData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SS_UpdateAccData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_SS_UpdateAccData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_SS_UpdateAccData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_SS_UpdateAccData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SS_UpdateAccData";
  }
  protected:
  explicit Msg_SS_UpdateAccData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
  };
  // optional .XrPb.Svr_Role_Info role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::Svr_Role_Info& role() const;
  PROTOBUF_NODISCARD ::XrPb::Svr_Role_Info* release_role();
  ::XrPb::Svr_Role_Info* mutable_role();
  void set_allocated_role(::XrPb::Svr_Role_Info* role);
  private:
  const ::XrPb::Svr_Role_Info& _internal_role() const;
  ::XrPb::Svr_Role_Info* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::Svr_Role_Info* role);
  ::XrPb::Svr_Role_Info* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SS_UpdateAccData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::XrPb::Svr_Role_Info* role_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class Msg_SS_UpdateRoleStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.Msg_SS_UpdateRoleStatus) */ {
 public:
  inline Msg_SS_UpdateRoleStatus() : Msg_SS_UpdateRoleStatus(nullptr) {}
  ~Msg_SS_UpdateRoleStatus() override;
  explicit constexpr Msg_SS_UpdateRoleStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg_SS_UpdateRoleStatus(const Msg_SS_UpdateRoleStatus& from);
  Msg_SS_UpdateRoleStatus(Msg_SS_UpdateRoleStatus&& from) noexcept
    : Msg_SS_UpdateRoleStatus() {
    *this = ::std::move(from);
  }

  inline Msg_SS_UpdateRoleStatus& operator=(const Msg_SS_UpdateRoleStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg_SS_UpdateRoleStatus& operator=(Msg_SS_UpdateRoleStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg_SS_UpdateRoleStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg_SS_UpdateRoleStatus* internal_default_instance() {
    return reinterpret_cast<const Msg_SS_UpdateRoleStatus*>(
               &_Msg_SS_UpdateRoleStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Msg_SS_UpdateRoleStatus& a, Msg_SS_UpdateRoleStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg_SS_UpdateRoleStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg_SS_UpdateRoleStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg_SS_UpdateRoleStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg_SS_UpdateRoleStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg_SS_UpdateRoleStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg_SS_UpdateRoleStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg_SS_UpdateRoleStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.Msg_SS_UpdateRoleStatus";
  }
  protected:
  explicit Msg_SS_UpdateRoleStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
  };
  // .XrPb.RoleOnLineStatus role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::XrPb::RoleOnLineStatus& role() const;
  PROTOBUF_NODISCARD ::XrPb::RoleOnLineStatus* release_role();
  ::XrPb::RoleOnLineStatus* mutable_role();
  void set_allocated_role(::XrPb::RoleOnLineStatus* role);
  private:
  const ::XrPb::RoleOnLineStatus& _internal_role() const;
  ::XrPb::RoleOnLineStatus* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::XrPb::RoleOnLineStatus* role);
  ::XrPb::RoleOnLineStatus* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:XrPb.Msg_SS_UpdateRoleStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::XrPb::RoleOnLineStatus* role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// -------------------------------------------------------------------

class RoleOnLineStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.RoleOnLineStatus) */ {
 public:
  inline RoleOnLineStatus() : RoleOnLineStatus(nullptr) {}
  ~RoleOnLineStatus() override;
  explicit constexpr RoleOnLineStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleOnLineStatus(const RoleOnLineStatus& from);
  RoleOnLineStatus(RoleOnLineStatus&& from) noexcept
    : RoleOnLineStatus() {
    *this = ::std::move(from);
  }

  inline RoleOnLineStatus& operator=(const RoleOnLineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleOnLineStatus& operator=(RoleOnLineStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleOnLineStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleOnLineStatus* internal_default_instance() {
    return reinterpret_cast<const RoleOnLineStatus*>(
               &_RoleOnLineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoleOnLineStatus& a, RoleOnLineStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleOnLineStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleOnLineStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleOnLineStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleOnLineStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleOnLineStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleOnLineStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleOnLineStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.RoleOnLineStatus";
  }
  protected:
  explicit RoleOnLineStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleidFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional int64 roleid = 1;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  int64_t roleid() const;
  void set_roleid(int64_t value);
  private:
  int64_t _internal_roleid() const;
  void _internal_set_roleid(int64_t value);
  public:

  // optional .XrPb.PlayerStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::XrPb::PlayerStatus status() const;
  void set_status(::XrPb::PlayerStatus value);
  private:
  ::XrPb::PlayerStatus _internal_status() const;
  void _internal_set_status(::XrPb::PlayerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.RoleOnLineStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t roleid_;
  int status_;
  friend struct ::TableStruct_server_2fMsgSvrCommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SvrMod_Com

// -------------------------------------------------------------------

// RoleFormInfo

// uint32 id = 1;
inline void RoleFormInfo::clear_id() {
  id_ = 0u;
}
inline uint32_t RoleFormInfo::_internal_id() const {
  return id_;
}
inline uint32_t RoleFormInfo::id() const {
  // @@protoc_insertion_point(field_get:XrPb.RoleFormInfo.id)
  return _internal_id();
}
inline void RoleFormInfo::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void RoleFormInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:XrPb.RoleFormInfo.id)
}

// -------------------------------------------------------------------

// Msg_SvrCommon

// -------------------------------------------------------------------

// Msg_SS_SvrReg_CS

// optional uint32 uiServerKind = 1;
inline bool Msg_SS_SvrReg_CS::_internal_has_uiserverkind() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_CS::has_uiserverkind() const {
  return _internal_has_uiserverkind();
}
inline void Msg_SS_SvrReg_CS::clear_uiserverkind() {
  uiserverkind_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Msg_SS_SvrReg_CS::_internal_uiserverkind() const {
  return uiserverkind_;
}
inline uint32_t Msg_SS_SvrReg_CS::uiserverkind() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_CS.uiServerKind)
  return _internal_uiserverkind();
}
inline void Msg_SS_SvrReg_CS::_internal_set_uiserverkind(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  uiserverkind_ = value;
}
inline void Msg_SS_SvrReg_CS::set_uiserverkind(uint32_t value) {
  _internal_set_uiserverkind(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_CS.uiServerKind)
}

// optional uint32 uiServerId = 2;
inline bool Msg_SS_SvrReg_CS::_internal_has_uiserverid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_CS::has_uiserverid() const {
  return _internal_has_uiserverid();
}
inline void Msg_SS_SvrReg_CS::clear_uiserverid() {
  uiserverid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Msg_SS_SvrReg_CS::_internal_uiserverid() const {
  return uiserverid_;
}
inline uint32_t Msg_SS_SvrReg_CS::uiserverid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_CS.uiServerId)
  return _internal_uiserverid();
}
inline void Msg_SS_SvrReg_CS::_internal_set_uiserverid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  uiserverid_ = value;
}
inline void Msg_SS_SvrReg_CS::set_uiserverid(uint32_t value) {
  _internal_set_uiserverid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_CS.uiServerId)
}

// optional uint32 platid = 3;
inline bool Msg_SS_SvrReg_CS::_internal_has_platid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_CS::has_platid() const {
  return _internal_has_platid();
}
inline void Msg_SS_SvrReg_CS::clear_platid() {
  platid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Msg_SS_SvrReg_CS::_internal_platid() const {
  return platid_;
}
inline uint32_t Msg_SS_SvrReg_CS::platid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_CS.platid)
  return _internal_platid();
}
inline void Msg_SS_SvrReg_CS::_internal_set_platid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  platid_ = value;
}
inline void Msg_SS_SvrReg_CS::set_platid(uint32_t value) {
  _internal_set_platid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_CS.platid)
}

// optional uint32 index = 4;
inline bool Msg_SS_SvrReg_CS::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_CS::has_index() const {
  return _internal_has_index();
}
inline void Msg_SS_SvrReg_CS::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Msg_SS_SvrReg_CS::_internal_index() const {
  return index_;
}
inline uint32_t Msg_SS_SvrReg_CS::index() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_CS.index)
  return _internal_index();
}
inline void Msg_SS_SvrReg_CS::_internal_set_index(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  index_ = value;
}
inline void Msg_SS_SvrReg_CS::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_CS.index)
}

// optional uint32 areano = 5;
inline bool Msg_SS_SvrReg_CS::_internal_has_areano() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_CS::has_areano() const {
  return _internal_has_areano();
}
inline void Msg_SS_SvrReg_CS::clear_areano() {
  areano_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Msg_SS_SvrReg_CS::_internal_areano() const {
  return areano_;
}
inline uint32_t Msg_SS_SvrReg_CS::areano() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_CS.areano)
  return _internal_areano();
}
inline void Msg_SS_SvrReg_CS::_internal_set_areano(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  areano_ = value;
}
inline void Msg_SS_SvrReg_CS::set_areano(uint32_t value) {
  _internal_set_areano(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_CS.areano)
}

// -------------------------------------------------------------------

// Msg_SS_SvrReg_SC

// optional uint32 uiServerKind = 1;
inline bool Msg_SS_SvrReg_SC::_internal_has_uiserverkind() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_SC::has_uiserverkind() const {
  return _internal_has_uiserverkind();
}
inline void Msg_SS_SvrReg_SC::clear_uiserverkind() {
  uiserverkind_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Msg_SS_SvrReg_SC::_internal_uiserverkind() const {
  return uiserverkind_;
}
inline uint32_t Msg_SS_SvrReg_SC::uiserverkind() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_SC.uiServerKind)
  return _internal_uiserverkind();
}
inline void Msg_SS_SvrReg_SC::_internal_set_uiserverkind(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  uiserverkind_ = value;
}
inline void Msg_SS_SvrReg_SC::set_uiserverkind(uint32_t value) {
  _internal_set_uiserverkind(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_SC.uiServerKind)
}

// optional uint32 uiServerId = 2;
inline bool Msg_SS_SvrReg_SC::_internal_has_uiserverid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_SS_SvrReg_SC::has_uiserverid() const {
  return _internal_has_uiserverid();
}
inline void Msg_SS_SvrReg_SC::clear_uiserverid() {
  uiserverid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Msg_SS_SvrReg_SC::_internal_uiserverid() const {
  return uiserverid_;
}
inline uint32_t Msg_SS_SvrReg_SC::uiserverid() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_SvrReg_SC.uiServerId)
  return _internal_uiserverid();
}
inline void Msg_SS_SvrReg_SC::_internal_set_uiserverid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  uiserverid_ = value;
}
inline void Msg_SS_SvrReg_SC::set_uiserverid(uint32_t value) {
  _internal_set_uiserverid(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_SvrReg_SC.uiServerId)
}

// -------------------------------------------------------------------

// Msg_SS_TransData

// optional uint32 seq_id = 1;
inline bool Msg_SS_TransData::_internal_has_seq_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Msg_SS_TransData::has_seq_id() const {
  return _internal_has_seq_id();
}
inline void Msg_SS_TransData::clear_seq_id() {
  seq_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Msg_SS_TransData::_internal_seq_id() const {
  return seq_id_;
}
inline uint32_t Msg_SS_TransData::seq_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.seq_id)
  return _internal_seq_id();
}
inline void Msg_SS_TransData::_internal_set_seq_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  seq_id_ = value;
}
inline void Msg_SS_TransData::set_seq_id(uint32_t value) {
  _internal_set_seq_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.seq_id)
}

// repeated int64 acc_lst = 2;
inline int Msg_SS_TransData::_internal_acc_lst_size() const {
  return acc_lst_.size();
}
inline int Msg_SS_TransData::acc_lst_size() const {
  return _internal_acc_lst_size();
}
inline void Msg_SS_TransData::clear_acc_lst() {
  acc_lst_.Clear();
}
inline int64_t Msg_SS_TransData::_internal_acc_lst(int index) const {
  return acc_lst_.Get(index);
}
inline int64_t Msg_SS_TransData::acc_lst(int index) const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.acc_lst)
  return _internal_acc_lst(index);
}
inline void Msg_SS_TransData::set_acc_lst(int index, int64_t value) {
  acc_lst_.Set(index, value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.acc_lst)
}
inline void Msg_SS_TransData::_internal_add_acc_lst(int64_t value) {
  acc_lst_.Add(value);
}
inline void Msg_SS_TransData::add_acc_lst(int64_t value) {
  _internal_add_acc_lst(value);
  // @@protoc_insertion_point(field_add:XrPb.Msg_SS_TransData.acc_lst)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Msg_SS_TransData::_internal_acc_lst() const {
  return acc_lst_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Msg_SS_TransData::acc_lst() const {
  // @@protoc_insertion_point(field_list:XrPb.Msg_SS_TransData.acc_lst)
  return _internal_acc_lst();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Msg_SS_TransData::_internal_mutable_acc_lst() {
  return &acc_lst_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Msg_SS_TransData::mutable_acc_lst() {
  // @@protoc_insertion_point(field_mutable_list:XrPb.Msg_SS_TransData.acc_lst)
  return _internal_mutable_acc_lst();
}

// optional bytes proto_msg = 3;
inline bool Msg_SS_TransData::_internal_has_proto_msg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Msg_SS_TransData::has_proto_msg() const {
  return _internal_has_proto_msg();
}
inline void Msg_SS_TransData::clear_proto_msg() {
  proto_msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Msg_SS_TransData::proto_msg() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.proto_msg)
  return _internal_proto_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Msg_SS_TransData::set_proto_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 proto_msg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.proto_msg)
}
inline std::string* Msg_SS_TransData::mutable_proto_msg() {
  std::string* _s = _internal_mutable_proto_msg();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_SS_TransData.proto_msg)
  return _s;
}
inline const std::string& Msg_SS_TransData::_internal_proto_msg() const {
  return proto_msg_.Get();
}
inline void Msg_SS_TransData::_internal_set_proto_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  proto_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Msg_SS_TransData::_internal_mutable_proto_msg() {
  _has_bits_[0] |= 0x00000001u;
  return proto_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Msg_SS_TransData::release_proto_msg() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_SS_TransData.proto_msg)
  if (!_internal_has_proto_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = proto_msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proto_msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proto_msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Msg_SS_TransData::set_allocated_proto_msg(std::string* proto_msg) {
  if (proto_msg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  proto_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proto_msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proto_msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proto_msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_SS_TransData.proto_msg)
}

// optional uint32 mod_id = 4;
inline bool Msg_SS_TransData::_internal_has_mod_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Msg_SS_TransData::has_mod_id() const {
  return _internal_has_mod_id();
}
inline void Msg_SS_TransData::clear_mod_id() {
  mod_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Msg_SS_TransData::_internal_mod_id() const {
  return mod_id_;
}
inline uint32_t Msg_SS_TransData::mod_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.mod_id)
  return _internal_mod_id();
}
inline void Msg_SS_TransData::_internal_set_mod_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  mod_id_ = value;
}
inline void Msg_SS_TransData::set_mod_id(uint32_t value) {
  _internal_set_mod_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.mod_id)
}

// optional uint32 proto_id = 5;
inline bool Msg_SS_TransData::_internal_has_proto_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Msg_SS_TransData::has_proto_id() const {
  return _internal_has_proto_id();
}
inline void Msg_SS_TransData::clear_proto_id() {
  proto_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Msg_SS_TransData::_internal_proto_id() const {
  return proto_id_;
}
inline uint32_t Msg_SS_TransData::proto_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.proto_id)
  return _internal_proto_id();
}
inline void Msg_SS_TransData::_internal_set_proto_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  proto_id_ = value;
}
inline void Msg_SS_TransData::set_proto_id(uint32_t value) {
  _internal_set_proto_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.proto_id)
}

// optional int32 ret_code = 6;
inline bool Msg_SS_TransData::_internal_has_ret_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Msg_SS_TransData::has_ret_code() const {
  return _internal_has_ret_code();
}
inline void Msg_SS_TransData::clear_ret_code() {
  ret_code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t Msg_SS_TransData::_internal_ret_code() const {
  return ret_code_;
}
inline int32_t Msg_SS_TransData::ret_code() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_TransData.ret_code)
  return _internal_ret_code();
}
inline void Msg_SS_TransData::_internal_set_ret_code(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  ret_code_ = value;
}
inline void Msg_SS_TransData::set_ret_code(int32_t value) {
  _internal_set_ret_code(value);
  // @@protoc_insertion_point(field_set:XrPb.Msg_SS_TransData.ret_code)
}

// -------------------------------------------------------------------

// Svr_Role_Info

// optional int64 acc_id = 1;
inline bool Svr_Role_Info::_internal_has_acc_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_acc_id() const {
  return _internal_has_acc_id();
}
inline void Svr_Role_Info::clear_acc_id() {
  acc_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t Svr_Role_Info::_internal_acc_id() const {
  return acc_id_;
}
inline int64_t Svr_Role_Info::acc_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.acc_id)
  return _internal_acc_id();
}
inline void Svr_Role_Info::_internal_set_acc_id(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  acc_id_ = value;
}
inline void Svr_Role_Info::set_acc_id(int64_t value) {
  _internal_set_acc_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.acc_id)
}

// optional string role_name = 2;
inline bool Svr_Role_Info::_internal_has_role_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_role_name() const {
  return _internal_has_role_name();
}
inline void Svr_Role_Info::clear_role_name() {
  role_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Svr_Role_Info::role_name() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Svr_Role_Info::set_role_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 role_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.role_name)
}
inline std::string* Svr_Role_Info::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:XrPb.Svr_Role_Info.role_name)
  return _s;
}
inline const std::string& Svr_Role_Info::_internal_role_name() const {
  return role_name_.Get();
}
inline void Svr_Role_Info::_internal_set_role_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  role_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Svr_Role_Info::_internal_mutable_role_name() {
  _has_bits_[0] |= 0x00000001u;
  return role_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Svr_Role_Info::release_role_name() {
  // @@protoc_insertion_point(field_release:XrPb.Svr_Role_Info.role_name)
  if (!_internal_has_role_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = role_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (role_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    role_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Svr_Role_Info::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  role_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (role_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    role_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.Svr_Role_Info.role_name)
}

// optional uint32 level = 3;
inline bool Svr_Role_Info::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_level() const {
  return _internal_has_level();
}
inline void Svr_Role_Info::clear_level() {
  level_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Svr_Role_Info::_internal_level() const {
  return level_;
}
inline uint32_t Svr_Role_Info::level() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.level)
  return _internal_level();
}
inline void Svr_Role_Info::_internal_set_level(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  level_ = value;
}
inline void Svr_Role_Info::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.level)
}

// optional .XrPb.FormData form = 4;
inline bool Svr_Role_Info::_internal_has_form() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || form_ != nullptr);
  return value;
}
inline bool Svr_Role_Info::has_form() const {
  return _internal_has_form();
}
inline const ::XrPb::FormData& Svr_Role_Info::_internal_form() const {
  const ::XrPb::FormData* p = form_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::FormData&>(
      ::XrPb::_FormData_default_instance_);
}
inline const ::XrPb::FormData& Svr_Role_Info::form() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.form)
  return _internal_form();
}
inline void Svr_Role_Info::unsafe_arena_set_allocated_form(
    ::XrPb::FormData* form) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_);
  }
  form_ = form;
  if (form) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Svr_Role_Info.form)
}
inline ::XrPb::FormData* Svr_Role_Info::release_form() {
  _has_bits_[0] &= ~0x00000002u;
  ::XrPb::FormData* temp = form_;
  form_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::FormData* Svr_Role_Info::unsafe_arena_release_form() {
  // @@protoc_insertion_point(field_release:XrPb.Svr_Role_Info.form)
  _has_bits_[0] &= ~0x00000002u;
  ::XrPb::FormData* temp = form_;
  form_ = nullptr;
  return temp;
}
inline ::XrPb::FormData* Svr_Role_Info::_internal_mutable_form() {
  _has_bits_[0] |= 0x00000002u;
  if (form_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::FormData>(GetArenaForAllocation());
    form_ = p;
  }
  return form_;
}
inline ::XrPb::FormData* Svr_Role_Info::mutable_form() {
  ::XrPb::FormData* _msg = _internal_mutable_form();
  // @@protoc_insertion_point(field_mutable:XrPb.Svr_Role_Info.form)
  return _msg;
}
inline void Svr_Role_Info::set_allocated_form(::XrPb::FormData* form) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_);
  }
  if (form) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form));
    if (message_arena != submessage_arena) {
      form = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  form_ = form;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Svr_Role_Info.form)
}

// optional uint32 gender = 5;
inline bool Svr_Role_Info::_internal_has_gender() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_gender() const {
  return _internal_has_gender();
}
inline void Svr_Role_Info::clear_gender() {
  gender_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Svr_Role_Info::_internal_gender() const {
  return gender_;
}
inline uint32_t Svr_Role_Info::gender() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.gender)
  return _internal_gender();
}
inline void Svr_Role_Info::_internal_set_gender(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  gender_ = value;
}
inline void Svr_Role_Info::set_gender(uint32_t value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.gender)
}

// optional .XrPb.PlayerStatus player_status = 6;
inline bool Svr_Role_Info::_internal_has_player_status() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_player_status() const {
  return _internal_has_player_status();
}
inline void Svr_Role_Info::clear_player_status() {
  player_status_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::XrPb::PlayerStatus Svr_Role_Info::_internal_player_status() const {
  return static_cast< ::XrPb::PlayerStatus >(player_status_);
}
inline ::XrPb::PlayerStatus Svr_Role_Info::player_status() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.player_status)
  return _internal_player_status();
}
inline void Svr_Role_Info::_internal_set_player_status(::XrPb::PlayerStatus value) {
  _has_bits_[0] |= 0x00000040u;
  player_status_ = value;
}
inline void Svr_Role_Info::set_player_status(::XrPb::PlayerStatus value) {
  _internal_set_player_status(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.player_status)
}

// optional int64 logout_time = 7;
inline bool Svr_Role_Info::_internal_has_logout_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_logout_time() const {
  return _internal_has_logout_time();
}
inline void Svr_Role_Info::clear_logout_time() {
  logout_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t Svr_Role_Info::_internal_logout_time() const {
  return logout_time_;
}
inline int64_t Svr_Role_Info::logout_time() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.logout_time)
  return _internal_logout_time();
}
inline void Svr_Role_Info::_internal_set_logout_time(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  logout_time_ = value;
}
inline void Svr_Role_Info::set_logout_time(int64_t value) {
  _internal_set_logout_time(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.logout_time)
}

// optional uint32 game_id = 8;
inline bool Svr_Role_Info::_internal_has_game_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_game_id() const {
  return _internal_has_game_id();
}
inline void Svr_Role_Info::clear_game_id() {
  game_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t Svr_Role_Info::_internal_game_id() const {
  return game_id_;
}
inline uint32_t Svr_Role_Info::game_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.game_id)
  return _internal_game_id();
}
inline void Svr_Role_Info::_internal_set_game_id(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  game_id_ = value;
}
inline void Svr_Role_Info::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.game_id)
}

// optional uint32 gate_id = 9;
inline bool Svr_Role_Info::_internal_has_gate_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Svr_Role_Info::has_gate_id() const {
  return _internal_has_gate_id();
}
inline void Svr_Role_Info::clear_gate_id() {
  gate_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t Svr_Role_Info::_internal_gate_id() const {
  return gate_id_;
}
inline uint32_t Svr_Role_Info::gate_id() const {
  // @@protoc_insertion_point(field_get:XrPb.Svr_Role_Info.gate_id)
  return _internal_gate_id();
}
inline void Svr_Role_Info::_internal_set_gate_id(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  gate_id_ = value;
}
inline void Svr_Role_Info::set_gate_id(uint32_t value) {
  _internal_set_gate_id(value);
  // @@protoc_insertion_point(field_set:XrPb.Svr_Role_Info.gate_id)
}

// -------------------------------------------------------------------

// Msg_SS_UpdateAccData

// optional .XrPb.Svr_Role_Info role = 1;
inline bool Msg_SS_UpdateAccData::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || role_ != nullptr);
  return value;
}
inline bool Msg_SS_UpdateAccData::has_role() const {
  return _internal_has_role();
}
inline void Msg_SS_UpdateAccData::clear_role() {
  if (role_ != nullptr) role_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::XrPb::Svr_Role_Info& Msg_SS_UpdateAccData::_internal_role() const {
  const ::XrPb::Svr_Role_Info* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::Svr_Role_Info&>(
      ::XrPb::_Svr_Role_Info_default_instance_);
}
inline const ::XrPb::Svr_Role_Info& Msg_SS_UpdateAccData::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_UpdateAccData.role)
  return _internal_role();
}
inline void Msg_SS_UpdateAccData::unsafe_arena_set_allocated_role(
    ::XrPb::Svr_Role_Info* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_SS_UpdateAccData.role)
}
inline ::XrPb::Svr_Role_Info* Msg_SS_UpdateAccData::release_role() {
  _has_bits_[0] &= ~0x00000001u;
  ::XrPb::Svr_Role_Info* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::Svr_Role_Info* Msg_SS_UpdateAccData::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_SS_UpdateAccData.role)
  _has_bits_[0] &= ~0x00000001u;
  ::XrPb::Svr_Role_Info* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::Svr_Role_Info* Msg_SS_UpdateAccData::_internal_mutable_role() {
  _has_bits_[0] |= 0x00000001u;
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::Svr_Role_Info>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::Svr_Role_Info* Msg_SS_UpdateAccData::mutable_role() {
  ::XrPb::Svr_Role_Info* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_SS_UpdateAccData.role)
  return _msg;
}
inline void Msg_SS_UpdateAccData::set_allocated_role(::XrPb::Svr_Role_Info* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::Svr_Role_Info>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_SS_UpdateAccData.role)
}

// -------------------------------------------------------------------

// Msg_SS_UpdateRoleStatus

// .XrPb.RoleOnLineStatus role = 1;
inline bool Msg_SS_UpdateRoleStatus::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool Msg_SS_UpdateRoleStatus::has_role() const {
  return _internal_has_role();
}
inline void Msg_SS_UpdateRoleStatus::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::XrPb::RoleOnLineStatus& Msg_SS_UpdateRoleStatus::_internal_role() const {
  const ::XrPb::RoleOnLineStatus* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::XrPb::RoleOnLineStatus&>(
      ::XrPb::_RoleOnLineStatus_default_instance_);
}
inline const ::XrPb::RoleOnLineStatus& Msg_SS_UpdateRoleStatus::role() const {
  // @@protoc_insertion_point(field_get:XrPb.Msg_SS_UpdateRoleStatus.role)
  return _internal_role();
}
inline void Msg_SS_UpdateRoleStatus::unsafe_arena_set_allocated_role(
    ::XrPb::RoleOnLineStatus* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:XrPb.Msg_SS_UpdateRoleStatus.role)
}
inline ::XrPb::RoleOnLineStatus* Msg_SS_UpdateRoleStatus::release_role() {
  
  ::XrPb::RoleOnLineStatus* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XrPb::RoleOnLineStatus* Msg_SS_UpdateRoleStatus::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:XrPb.Msg_SS_UpdateRoleStatus.role)
  
  ::XrPb::RoleOnLineStatus* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::XrPb::RoleOnLineStatus* Msg_SS_UpdateRoleStatus::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::XrPb::RoleOnLineStatus>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::XrPb::RoleOnLineStatus* Msg_SS_UpdateRoleStatus::mutable_role() {
  ::XrPb::RoleOnLineStatus* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:XrPb.Msg_SS_UpdateRoleStatus.role)
  return _msg;
}
inline void Msg_SS_UpdateRoleStatus::set_allocated_role(::XrPb::RoleOnLineStatus* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XrPb::RoleOnLineStatus>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:XrPb.Msg_SS_UpdateRoleStatus.role)
}

// -------------------------------------------------------------------

// RoleOnLineStatus

// optional int64 roleid = 1;
inline bool RoleOnLineStatus::_internal_has_roleid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleOnLineStatus::has_roleid() const {
  return _internal_has_roleid();
}
inline void RoleOnLineStatus::clear_roleid() {
  roleid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RoleOnLineStatus::_internal_roleid() const {
  return roleid_;
}
inline int64_t RoleOnLineStatus::roleid() const {
  // @@protoc_insertion_point(field_get:XrPb.RoleOnLineStatus.roleid)
  return _internal_roleid();
}
inline void RoleOnLineStatus::_internal_set_roleid(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  roleid_ = value;
}
inline void RoleOnLineStatus::set_roleid(int64_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:XrPb.RoleOnLineStatus.roleid)
}

// optional .XrPb.PlayerStatus status = 2;
inline bool RoleOnLineStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleOnLineStatus::has_status() const {
  return _internal_has_status();
}
inline void RoleOnLineStatus::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::XrPb::PlayerStatus RoleOnLineStatus::_internal_status() const {
  return static_cast< ::XrPb::PlayerStatus >(status_);
}
inline ::XrPb::PlayerStatus RoleOnLineStatus::status() const {
  // @@protoc_insertion_point(field_get:XrPb.RoleOnLineStatus.status)
  return _internal_status();
}
inline void RoleOnLineStatus::_internal_set_status(::XrPb::PlayerStatus value) {
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void RoleOnLineStatus::set_status(::XrPb::PlayerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:XrPb.RoleOnLineStatus.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XrPb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XrPb::SvrMod_Com_MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::SvrMod_Com_MsgId>() {
  return ::XrPb::SvrMod_Com_MsgId_descriptor();
}
template <> struct is_proto_enum< ::XrPb::Msg_SvrCommon_MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::Msg_SvrCommon_MsgId>() {
  return ::XrPb::Msg_SvrCommon_MsgId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2fMsgSvrCommon_2eproto
