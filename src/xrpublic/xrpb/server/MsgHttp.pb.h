// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server/MsgHttp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2fMsgHttp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2fMsgHttp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client/Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2fMsgHttp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2fMsgHttp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2fMsgHttp_2eproto;
namespace XrPb {
class HttpModifyNameRet;
struct HttpModifyNameRetDefaultTypeInternal;
extern HttpModifyNameRetDefaultTypeInternal _HttpModifyNameRet_default_instance_;
class HttpRetMsg;
struct HttpRetMsgDefaultTypeInternal;
extern HttpRetMsgDefaultTypeInternal _HttpRetMsg_default_instance_;
class HttpUploadFileRet;
struct HttpUploadFileRetDefaultTypeInternal;
extern HttpUploadFileRetDefaultTypeInternal _HttpUploadFileRet_default_instance_;
class HttpUserLoginRet;
struct HttpUserLoginRetDefaultTypeInternal;
extern HttpUserLoginRetDefaultTypeInternal _HttpUserLoginRet_default_instance_;
class MsgSvrMod_Http;
struct MsgSvrMod_HttpDefaultTypeInternal;
extern MsgSvrMod_HttpDefaultTypeInternal _MsgSvrMod_Http_default_instance_;
}  // namespace XrPb
PROTOBUF_NAMESPACE_OPEN
template<> ::XrPb::HttpModifyNameRet* Arena::CreateMaybeMessage<::XrPb::HttpModifyNameRet>(Arena*);
template<> ::XrPb::HttpRetMsg* Arena::CreateMaybeMessage<::XrPb::HttpRetMsg>(Arena*);
template<> ::XrPb::HttpUploadFileRet* Arena::CreateMaybeMessage<::XrPb::HttpUploadFileRet>(Arena*);
template<> ::XrPb::HttpUserLoginRet* Arena::CreateMaybeMessage<::XrPb::HttpUserLoginRet>(Arena*);
template<> ::XrPb::MsgSvrMod_Http* Arena::CreateMaybeMessage<::XrPb::MsgSvrMod_Http>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace XrPb {

enum MsgSvrMod_Http_MsgId : int {
  MsgSvrMod_Http_MsgId_Msg_Http_None = 0,
  MsgSvrMod_Http_MsgId_Msg_Http_NewMail_CS = 1,
  MsgSvrMod_Http_MsgId_Msg_Http_NewMail_SC = 2,
  MsgSvrMod_Http_MsgId_Msg_Http_OpenDate_CS = 3,
  MsgSvrMod_Http_MsgId_Msg_Http_OpenDate_SC = 4,
  MsgSvrMod_Http_MsgId_Msg_Http_UpdateNotice_CS = 5,
  MsgSvrMod_Http_MsgId_Msg_Http_UpdateNotice_SC = 6,
  MsgSvrMod_Http_MsgId_Msg_Http_NotifyRecharge_CS = 7,
  MsgSvrMod_Http_MsgId_Msg_Http_NotifyRecharge_SC = 8,
  MsgSvrMod_Http_MsgId_Msg_Http_KickUser_CS = 9,
  MsgSvrMod_Http_MsgId_Msg_Http_KickUser_SC = 10,
  MsgSvrMod_Http_MsgId_Msg_Http_ForbidChat_CS = 11,
  MsgSvrMod_Http_MsgId_Msg_Http_ForbidChat_SC = 12,
  MsgSvrMod_Http_MsgId_Msg_Http_UnForbidChat_CS = 13,
  MsgSvrMod_Http_MsgId_Msg_Http_UnForbidChat_SC = 14,
  MsgSvrMod_Http_MsgId_Msg_Http_KillAllPlayer_CS = 17,
  MsgSvrMod_Http_MsgId_Msg_Http_KillAllPlayer_SC = 18,
  MsgSvrMod_Http_MsgId_Msg_Http_UpdateData_CS = 19,
  MsgSvrMod_Http_MsgId_Msg_Http_UpdateData_SC = 20,
  MsgSvrMod_Http_MsgId_Msg_Http_ModifyCredit_CS = 21,
  MsgSvrMod_Http_MsgId_Msg_Http_ModifyCredit_SC = 22,
  MsgSvrMod_Http_MsgId_MsgSvrMod_Http_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgSvrMod_Http_MsgId_MsgSvrMod_Http_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgSvrMod_Http_MsgId_IsValid(int value);
constexpr MsgSvrMod_Http_MsgId MsgSvrMod_Http_MsgId_MsgId_MIN = MsgSvrMod_Http_MsgId_Msg_Http_None;
constexpr MsgSvrMod_Http_MsgId MsgSvrMod_Http_MsgId_MsgId_MAX = MsgSvrMod_Http_MsgId_Msg_Http_ModifyCredit_SC;
constexpr int MsgSvrMod_Http_MsgId_MsgId_ARRAYSIZE = MsgSvrMod_Http_MsgId_MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgSvrMod_Http_MsgId_descriptor();
template<typename T>
inline const std::string& MsgSvrMod_Http_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgSvrMod_Http_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgSvrMod_Http_MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgSvrMod_Http_MsgId_descriptor(), enum_t_value);
}
inline bool MsgSvrMod_Http_MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgSvrMod_Http_MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgSvrMod_Http_MsgId>(
    MsgSvrMod_Http_MsgId_descriptor(), name, value);
}
// ===================================================================

class MsgSvrMod_Http final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:XrPb.MsgSvrMod_Http) */ {
 public:
  inline MsgSvrMod_Http() : MsgSvrMod_Http(nullptr) {}
  explicit constexpr MsgSvrMod_Http(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSvrMod_Http(const MsgSvrMod_Http& from);
  MsgSvrMod_Http(MsgSvrMod_Http&& from) noexcept
    : MsgSvrMod_Http() {
    *this = ::std::move(from);
  }

  inline MsgSvrMod_Http& operator=(const MsgSvrMod_Http& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSvrMod_Http& operator=(MsgSvrMod_Http&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSvrMod_Http& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSvrMod_Http* internal_default_instance() {
    return reinterpret_cast<const MsgSvrMod_Http*>(
               &_MsgSvrMod_Http_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgSvrMod_Http& a, MsgSvrMod_Http& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSvrMod_Http* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSvrMod_Http* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSvrMod_Http* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSvrMod_Http>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgSvrMod_Http& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgSvrMod_Http& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.MsgSvrMod_Http";
  }
  protected:
  explicit MsgSvrMod_Http(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MsgSvrMod_Http_MsgId MsgId;
  static constexpr MsgId Msg_Http_None =
    MsgSvrMod_Http_MsgId_Msg_Http_None;
  static constexpr MsgId Msg_Http_NewMail_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_NewMail_CS;
  static constexpr MsgId Msg_Http_NewMail_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_NewMail_SC;
  static constexpr MsgId Msg_Http_OpenDate_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_OpenDate_CS;
  static constexpr MsgId Msg_Http_OpenDate_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_OpenDate_SC;
  static constexpr MsgId Msg_Http_UpdateNotice_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_UpdateNotice_CS;
  static constexpr MsgId Msg_Http_UpdateNotice_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_UpdateNotice_SC;
  static constexpr MsgId Msg_Http_NotifyRecharge_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_NotifyRecharge_CS;
  static constexpr MsgId Msg_Http_NotifyRecharge_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_NotifyRecharge_SC;
  static constexpr MsgId Msg_Http_KickUser_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_KickUser_CS;
  static constexpr MsgId Msg_Http_KickUser_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_KickUser_SC;
  static constexpr MsgId Msg_Http_ForbidChat_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_ForbidChat_CS;
  static constexpr MsgId Msg_Http_ForbidChat_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_ForbidChat_SC;
  static constexpr MsgId Msg_Http_UnForbidChat_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_UnForbidChat_CS;
  static constexpr MsgId Msg_Http_UnForbidChat_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_UnForbidChat_SC;
  static constexpr MsgId Msg_Http_KillAllPlayer_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_KillAllPlayer_CS;
  static constexpr MsgId Msg_Http_KillAllPlayer_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_KillAllPlayer_SC;
  static constexpr MsgId Msg_Http_UpdateData_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_UpdateData_CS;
  static constexpr MsgId Msg_Http_UpdateData_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_UpdateData_SC;
  static constexpr MsgId Msg_Http_ModifyCredit_CS =
    MsgSvrMod_Http_MsgId_Msg_Http_ModifyCredit_CS;
  static constexpr MsgId Msg_Http_ModifyCredit_SC =
    MsgSvrMod_Http_MsgId_Msg_Http_ModifyCredit_SC;
  static inline bool MsgId_IsValid(int value) {
    return MsgSvrMod_Http_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    MsgSvrMod_Http_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    MsgSvrMod_Http_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    MsgSvrMod_Http_MsgId_MsgId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgId_descriptor() {
    return MsgSvrMod_Http_MsgId_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return MsgSvrMod_Http_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgId* value) {
    return MsgSvrMod_Http_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:XrPb.MsgSvrMod_Http)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgHttp_2eproto;
};
// -------------------------------------------------------------------

class HttpRetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.HttpRetMsg) */ {
 public:
  inline HttpRetMsg() : HttpRetMsg(nullptr) {}
  ~HttpRetMsg() override;
  explicit constexpr HttpRetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpRetMsg(const HttpRetMsg& from);
  HttpRetMsg(HttpRetMsg&& from) noexcept
    : HttpRetMsg() {
    *this = ::std::move(from);
  }

  inline HttpRetMsg& operator=(const HttpRetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRetMsg& operator=(HttpRetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpRetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpRetMsg* internal_default_instance() {
    return reinterpret_cast<const HttpRetMsg*>(
               &_HttpRetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HttpRetMsg& a, HttpRetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpRetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpRetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpRetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpRetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpRetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HttpRetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpRetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.HttpRetMsg";
  }
  protected:
  explicit HttpRetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // bytes msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint32 msgid = 1;
  void clear_msgid();
  uint32_t msgid() const;
  void set_msgid(uint32_t value);
  private:
  uint32_t _internal_msgid() const;
  void _internal_set_msgid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.HttpRetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  uint32_t msgid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgHttp_2eproto;
};
// -------------------------------------------------------------------

class HttpUserLoginRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.HttpUserLoginRet) */ {
 public:
  inline HttpUserLoginRet() : HttpUserLoginRet(nullptr) {}
  ~HttpUserLoginRet() override;
  explicit constexpr HttpUserLoginRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpUserLoginRet(const HttpUserLoginRet& from);
  HttpUserLoginRet(HttpUserLoginRet&& from) noexcept
    : HttpUserLoginRet() {
    *this = ::std::move(from);
  }

  inline HttpUserLoginRet& operator=(const HttpUserLoginRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpUserLoginRet& operator=(HttpUserLoginRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpUserLoginRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpUserLoginRet* internal_default_instance() {
    return reinterpret_cast<const HttpUserLoginRet*>(
               &_HttpUserLoginRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HttpUserLoginRet& a, HttpUserLoginRet& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpUserLoginRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpUserLoginRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpUserLoginRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpUserLoginRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpUserLoginRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HttpUserLoginRet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpUserLoginRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.HttpUserLoginRet";
  }
  protected:
  explicit HttpUserLoginRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvincenameFieldNumber = 5,
    kSessionidFieldNumber = 6,
    kDevidFieldNumber = 8,
    kAccidFieldNumber = 1,
    kEResultFieldNumber = 2,
    kGateidFieldNumber = 3,
    kProvinceFieldNumber = 4,
    kGmlevelFieldNumber = 7,
    kProareaFieldNumber = 9,
  };
  // optional string provincename = 5;
  bool has_provincename() const;
  private:
  bool _internal_has_provincename() const;
  public:
  void clear_provincename();
  const std::string& provincename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provincename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provincename();
  PROTOBUF_NODISCARD std::string* release_provincename();
  void set_allocated_provincename(std::string* provincename);
  private:
  const std::string& _internal_provincename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provincename(const std::string& value);
  std::string* _internal_mutable_provincename();
  public:

  // optional string sessionid = 6;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // optional string devid = 8;
  bool has_devid() const;
  private:
  bool _internal_has_devid() const;
  public:
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_NODISCARD std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int64 accid = 1;
  void clear_accid();
  int64_t accid() const;
  void set_accid(int64_t value);
  private:
  int64_t _internal_accid() const;
  void _internal_set_accid(int64_t value);
  public:

  // .XrPb.ResultCode eResult = 2;
  void clear_eresult();
  ::XrPb::ResultCode eresult() const;
  void set_eresult(::XrPb::ResultCode value);
  private:
  ::XrPb::ResultCode _internal_eresult() const;
  void _internal_set_eresult(::XrPb::ResultCode value);
  public:

  // optional uint32 gateid = 3;
  bool has_gateid() const;
  private:
  bool _internal_has_gateid() const;
  public:
  void clear_gateid();
  uint32_t gateid() const;
  void set_gateid(uint32_t value);
  private:
  uint32_t _internal_gateid() const;
  void _internal_set_gateid(uint32_t value);
  public:

  // optional int32 province = 4;
  bool has_province() const;
  private:
  bool _internal_has_province() const;
  public:
  void clear_province();
  int32_t province() const;
  void set_province(int32_t value);
  private:
  int32_t _internal_province() const;
  void _internal_set_province(int32_t value);
  public:

  // optional uint32 gmlevel = 7;
  bool has_gmlevel() const;
  private:
  bool _internal_has_gmlevel() const;
  public:
  void clear_gmlevel();
  uint32_t gmlevel() const;
  void set_gmlevel(uint32_t value);
  private:
  uint32_t _internal_gmlevel() const;
  void _internal_set_gmlevel(uint32_t value);
  public:

  // optional uint32 proarea = 9;
  bool has_proarea() const;
  private:
  bool _internal_has_proarea() const;
  public:
  void clear_proarea();
  uint32_t proarea() const;
  void set_proarea(uint32_t value);
  private:
  uint32_t _internal_proarea() const;
  void _internal_set_proarea(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.HttpUserLoginRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provincename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  int64_t accid_;
  int eresult_;
  uint32_t gateid_;
  int32_t province_;
  uint32_t gmlevel_;
  uint32_t proarea_;
  friend struct ::TableStruct_server_2fMsgHttp_2eproto;
};
// -------------------------------------------------------------------

class HttpUploadFileRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.HttpUploadFileRet) */ {
 public:
  inline HttpUploadFileRet() : HttpUploadFileRet(nullptr) {}
  ~HttpUploadFileRet() override;
  explicit constexpr HttpUploadFileRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpUploadFileRet(const HttpUploadFileRet& from);
  HttpUploadFileRet(HttpUploadFileRet&& from) noexcept
    : HttpUploadFileRet() {
    *this = ::std::move(from);
  }

  inline HttpUploadFileRet& operator=(const HttpUploadFileRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpUploadFileRet& operator=(HttpUploadFileRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpUploadFileRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpUploadFileRet* internal_default_instance() {
    return reinterpret_cast<const HttpUploadFileRet*>(
               &_HttpUploadFileRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HttpUploadFileRet& a, HttpUploadFileRet& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpUploadFileRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpUploadFileRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpUploadFileRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpUploadFileRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpUploadFileRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HttpUploadFileRet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpUploadFileRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.HttpUploadFileRet";
  }
  protected:
  explicit HttpUploadFileRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kRetFieldNumber = 3,
    kCodeFieldNumber = 2,
    kCosFieldNumber = 4,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string ret = 3;
  bool has_ret() const;
  private:
  bool _internal_has_ret() const;
  public:
  void clear_ret();
  const std::string& ret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ret();
  PROTOBUF_NODISCARD std::string* release_ret();
  void set_allocated_ret(std::string* ret);
  private:
  const std::string& _internal_ret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ret(const std::string& value);
  std::string* _internal_mutable_ret();
  public:

  // optional int32 code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // optional bool cos = 4;
  bool has_cos() const;
  private:
  bool _internal_has_cos() const;
  public:
  void clear_cos();
  bool cos() const;
  void set_cos(bool value);
  private:
  bool _internal_cos() const;
  void _internal_set_cos(bool value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.HttpUploadFileRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ret_;
  int32_t code_;
  bool cos_;
  friend struct ::TableStruct_server_2fMsgHttp_2eproto;
};
// -------------------------------------------------------------------

class HttpModifyNameRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XrPb.HttpModifyNameRet) */ {
 public:
  inline HttpModifyNameRet() : HttpModifyNameRet(nullptr) {}
  ~HttpModifyNameRet() override;
  explicit constexpr HttpModifyNameRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpModifyNameRet(const HttpModifyNameRet& from);
  HttpModifyNameRet(HttpModifyNameRet&& from) noexcept
    : HttpModifyNameRet() {
    *this = ::std::move(from);
  }

  inline HttpModifyNameRet& operator=(const HttpModifyNameRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpModifyNameRet& operator=(HttpModifyNameRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpModifyNameRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpModifyNameRet* internal_default_instance() {
    return reinterpret_cast<const HttpModifyNameRet*>(
               &_HttpModifyNameRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HttpModifyNameRet& a, HttpModifyNameRet& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpModifyNameRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpModifyNameRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpModifyNameRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpModifyNameRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpModifyNameRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HttpModifyNameRet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpModifyNameRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XrPb.HttpModifyNameRet";
  }
  protected:
  explicit HttpModifyNameRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolenameFieldNumber = 4,
    kAccidFieldNumber = 1,
    kEResultFieldNumber = 2,
    kServeridFieldNumber = 3,
  };
  // string rolename = 4;
  void clear_rolename();
  const std::string& rolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rolename();
  PROTOBUF_NODISCARD std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);
  private:
  const std::string& _internal_rolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rolename(const std::string& value);
  std::string* _internal_mutable_rolename();
  public:

  // int64 accid = 1;
  void clear_accid();
  int64_t accid() const;
  void set_accid(int64_t value);
  private:
  int64_t _internal_accid() const;
  void _internal_set_accid(int64_t value);
  public:

  // .XrPb.ResultCode eResult = 2;
  void clear_eresult();
  ::XrPb::ResultCode eresult() const;
  void set_eresult(::XrPb::ResultCode value);
  private:
  ::XrPb::ResultCode _internal_eresult() const;
  void _internal_set_eresult(::XrPb::ResultCode value);
  public:

  // uint32 serverid = 3;
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:XrPb.HttpModifyNameRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  int64_t accid_;
  int eresult_;
  uint32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2fMsgHttp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgSvrMod_Http

// -------------------------------------------------------------------

// HttpRetMsg

// uint32 msgid = 1;
inline void HttpRetMsg::clear_msgid() {
  msgid_ = 0u;
}
inline uint32_t HttpRetMsg::_internal_msgid() const {
  return msgid_;
}
inline uint32_t HttpRetMsg::msgid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpRetMsg.msgid)
  return _internal_msgid();
}
inline void HttpRetMsg::_internal_set_msgid(uint32_t value) {
  
  msgid_ = value;
}
inline void HttpRetMsg::set_msgid(uint32_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpRetMsg.msgid)
}

// bytes msg = 2;
inline void HttpRetMsg::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& HttpRetMsg::msg() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpRetMsg.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRetMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpRetMsg.msg)
}
inline std::string* HttpRetMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpRetMsg.msg)
  return _s;
}
inline const std::string& HttpRetMsg::_internal_msg() const {
  return msg_.Get();
}
inline void HttpRetMsg::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpRetMsg::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpRetMsg::release_msg() {
  // @@protoc_insertion_point(field_release:XrPb.HttpRetMsg.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HttpRetMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpRetMsg.msg)
}

// -------------------------------------------------------------------

// HttpUserLoginRet

// int64 accid = 1;
inline void HttpUserLoginRet::clear_accid() {
  accid_ = int64_t{0};
}
inline int64_t HttpUserLoginRet::_internal_accid() const {
  return accid_;
}
inline int64_t HttpUserLoginRet::accid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.accid)
  return _internal_accid();
}
inline void HttpUserLoginRet::_internal_set_accid(int64_t value) {
  
  accid_ = value;
}
inline void HttpUserLoginRet::set_accid(int64_t value) {
  _internal_set_accid(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.accid)
}

// .XrPb.ResultCode eResult = 2;
inline void HttpUserLoginRet::clear_eresult() {
  eresult_ = 0;
}
inline ::XrPb::ResultCode HttpUserLoginRet::_internal_eresult() const {
  return static_cast< ::XrPb::ResultCode >(eresult_);
}
inline ::XrPb::ResultCode HttpUserLoginRet::eresult() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.eResult)
  return _internal_eresult();
}
inline void HttpUserLoginRet::_internal_set_eresult(::XrPb::ResultCode value) {
  
  eresult_ = value;
}
inline void HttpUserLoginRet::set_eresult(::XrPb::ResultCode value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.eResult)
}

// optional uint32 gateid = 3;
inline bool HttpUserLoginRet::_internal_has_gateid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_gateid() const {
  return _internal_has_gateid();
}
inline void HttpUserLoginRet::clear_gateid() {
  gateid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t HttpUserLoginRet::_internal_gateid() const {
  return gateid_;
}
inline uint32_t HttpUserLoginRet::gateid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.gateid)
  return _internal_gateid();
}
inline void HttpUserLoginRet::_internal_set_gateid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  gateid_ = value;
}
inline void HttpUserLoginRet::set_gateid(uint32_t value) {
  _internal_set_gateid(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.gateid)
}

// optional int32 province = 4;
inline bool HttpUserLoginRet::_internal_has_province() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_province() const {
  return _internal_has_province();
}
inline void HttpUserLoginRet::clear_province() {
  province_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t HttpUserLoginRet::_internal_province() const {
  return province_;
}
inline int32_t HttpUserLoginRet::province() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.province)
  return _internal_province();
}
inline void HttpUserLoginRet::_internal_set_province(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  province_ = value;
}
inline void HttpUserLoginRet::set_province(int32_t value) {
  _internal_set_province(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.province)
}

// optional string provincename = 5;
inline bool HttpUserLoginRet::_internal_has_provincename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_provincename() const {
  return _internal_has_provincename();
}
inline void HttpUserLoginRet::clear_provincename() {
  provincename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HttpUserLoginRet::provincename() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.provincename)
  return _internal_provincename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpUserLoginRet::set_provincename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 provincename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.provincename)
}
inline std::string* HttpUserLoginRet::mutable_provincename() {
  std::string* _s = _internal_mutable_provincename();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpUserLoginRet.provincename)
  return _s;
}
inline const std::string& HttpUserLoginRet::_internal_provincename() const {
  return provincename_.Get();
}
inline void HttpUserLoginRet::_internal_set_provincename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  provincename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::_internal_mutable_provincename() {
  _has_bits_[0] |= 0x00000001u;
  return provincename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::release_provincename() {
  // @@protoc_insertion_point(field_release:XrPb.HttpUserLoginRet.provincename)
  if (!_internal_has_provincename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = provincename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (provincename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    provincename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpUserLoginRet::set_allocated_provincename(std::string* provincename) {
  if (provincename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  provincename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), provincename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (provincename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    provincename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpUserLoginRet.provincename)
}

// optional string sessionid = 6;
inline bool HttpUserLoginRet::_internal_has_sessionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void HttpUserLoginRet::clear_sessionid() {
  sessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HttpUserLoginRet::sessionid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.sessionid)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpUserLoginRet::set_sessionid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.sessionid)
}
inline std::string* HttpUserLoginRet::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpUserLoginRet.sessionid)
  return _s;
}
inline const std::string& HttpUserLoginRet::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void HttpUserLoginRet::_internal_set_sessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::_internal_mutable_sessionid() {
  _has_bits_[0] |= 0x00000002u;
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::release_sessionid() {
  // @@protoc_insertion_point(field_release:XrPb.HttpUserLoginRet.sessionid)
  if (!_internal_has_sessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpUserLoginRet::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpUserLoginRet.sessionid)
}

// optional uint32 gmlevel = 7;
inline bool HttpUserLoginRet::_internal_has_gmlevel() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_gmlevel() const {
  return _internal_has_gmlevel();
}
inline void HttpUserLoginRet::clear_gmlevel() {
  gmlevel_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t HttpUserLoginRet::_internal_gmlevel() const {
  return gmlevel_;
}
inline uint32_t HttpUserLoginRet::gmlevel() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.gmlevel)
  return _internal_gmlevel();
}
inline void HttpUserLoginRet::_internal_set_gmlevel(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  gmlevel_ = value;
}
inline void HttpUserLoginRet::set_gmlevel(uint32_t value) {
  _internal_set_gmlevel(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.gmlevel)
}

// optional string devid = 8;
inline bool HttpUserLoginRet::_internal_has_devid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_devid() const {
  return _internal_has_devid();
}
inline void HttpUserLoginRet::clear_devid() {
  devid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HttpUserLoginRet::devid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpUserLoginRet::set_devid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.devid)
}
inline std::string* HttpUserLoginRet::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpUserLoginRet.devid)
  return _s;
}
inline const std::string& HttpUserLoginRet::_internal_devid() const {
  return devid_.Get();
}
inline void HttpUserLoginRet::_internal_set_devid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::_internal_mutable_devid() {
  _has_bits_[0] |= 0x00000004u;
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpUserLoginRet::release_devid() {
  // @@protoc_insertion_point(field_release:XrPb.HttpUserLoginRet.devid)
  if (!_internal_has_devid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = devid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (devid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    devid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpUserLoginRet::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (devid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    devid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpUserLoginRet.devid)
}

// optional uint32 proarea = 9;
inline bool HttpUserLoginRet::_internal_has_proarea() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool HttpUserLoginRet::has_proarea() const {
  return _internal_has_proarea();
}
inline void HttpUserLoginRet::clear_proarea() {
  proarea_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t HttpUserLoginRet::_internal_proarea() const {
  return proarea_;
}
inline uint32_t HttpUserLoginRet::proarea() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUserLoginRet.proarea)
  return _internal_proarea();
}
inline void HttpUserLoginRet::_internal_set_proarea(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  proarea_ = value;
}
inline void HttpUserLoginRet::set_proarea(uint32_t value) {
  _internal_set_proarea(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUserLoginRet.proarea)
}

// -------------------------------------------------------------------

// HttpUploadFileRet

// optional string filename = 1;
inline bool HttpUploadFileRet::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HttpUploadFileRet::has_filename() const {
  return _internal_has_filename();
}
inline void HttpUploadFileRet::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HttpUploadFileRet::filename() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUploadFileRet.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpUploadFileRet::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpUploadFileRet.filename)
}
inline std::string* HttpUploadFileRet::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpUploadFileRet.filename)
  return _s;
}
inline const std::string& HttpUploadFileRet::_internal_filename() const {
  return filename_.Get();
}
inline void HttpUploadFileRet::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpUploadFileRet::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpUploadFileRet::release_filename() {
  // @@protoc_insertion_point(field_release:XrPb.HttpUploadFileRet.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpUploadFileRet::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpUploadFileRet.filename)
}

// optional int32 code = 2;
inline bool HttpUploadFileRet::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HttpUploadFileRet::has_code() const {
  return _internal_has_code();
}
inline void HttpUploadFileRet::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t HttpUploadFileRet::_internal_code() const {
  return code_;
}
inline int32_t HttpUploadFileRet::code() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUploadFileRet.code)
  return _internal_code();
}
inline void HttpUploadFileRet::_internal_set_code(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  code_ = value;
}
inline void HttpUploadFileRet::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUploadFileRet.code)
}

// optional string ret = 3;
inline bool HttpUploadFileRet::_internal_has_ret() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HttpUploadFileRet::has_ret() const {
  return _internal_has_ret();
}
inline void HttpUploadFileRet::clear_ret() {
  ret_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HttpUploadFileRet::ret() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUploadFileRet.ret)
  return _internal_ret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpUploadFileRet::set_ret(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpUploadFileRet.ret)
}
inline std::string* HttpUploadFileRet::mutable_ret() {
  std::string* _s = _internal_mutable_ret();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpUploadFileRet.ret)
  return _s;
}
inline const std::string& HttpUploadFileRet::_internal_ret() const {
  return ret_.Get();
}
inline void HttpUploadFileRet::_internal_set_ret(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpUploadFileRet::_internal_mutable_ret() {
  _has_bits_[0] |= 0x00000002u;
  return ret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpUploadFileRet::release_ret() {
  // @@protoc_insertion_point(field_release:XrPb.HttpUploadFileRet.ret)
  if (!_internal_has_ret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ret_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpUploadFileRet::set_allocated_ret(std::string* ret) {
  if (ret != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ret,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpUploadFileRet.ret)
}

// optional bool cos = 4;
inline bool HttpUploadFileRet::_internal_has_cos() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HttpUploadFileRet::has_cos() const {
  return _internal_has_cos();
}
inline void HttpUploadFileRet::clear_cos() {
  cos_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool HttpUploadFileRet::_internal_cos() const {
  return cos_;
}
inline bool HttpUploadFileRet::cos() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpUploadFileRet.cos)
  return _internal_cos();
}
inline void HttpUploadFileRet::_internal_set_cos(bool value) {
  _has_bits_[0] |= 0x00000008u;
  cos_ = value;
}
inline void HttpUploadFileRet::set_cos(bool value) {
  _internal_set_cos(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpUploadFileRet.cos)
}

// -------------------------------------------------------------------

// HttpModifyNameRet

// int64 accid = 1;
inline void HttpModifyNameRet::clear_accid() {
  accid_ = int64_t{0};
}
inline int64_t HttpModifyNameRet::_internal_accid() const {
  return accid_;
}
inline int64_t HttpModifyNameRet::accid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpModifyNameRet.accid)
  return _internal_accid();
}
inline void HttpModifyNameRet::_internal_set_accid(int64_t value) {
  
  accid_ = value;
}
inline void HttpModifyNameRet::set_accid(int64_t value) {
  _internal_set_accid(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpModifyNameRet.accid)
}

// .XrPb.ResultCode eResult = 2;
inline void HttpModifyNameRet::clear_eresult() {
  eresult_ = 0;
}
inline ::XrPb::ResultCode HttpModifyNameRet::_internal_eresult() const {
  return static_cast< ::XrPb::ResultCode >(eresult_);
}
inline ::XrPb::ResultCode HttpModifyNameRet::eresult() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpModifyNameRet.eResult)
  return _internal_eresult();
}
inline void HttpModifyNameRet::_internal_set_eresult(::XrPb::ResultCode value) {
  
  eresult_ = value;
}
inline void HttpModifyNameRet::set_eresult(::XrPb::ResultCode value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpModifyNameRet.eResult)
}

// uint32 serverid = 3;
inline void HttpModifyNameRet::clear_serverid() {
  serverid_ = 0u;
}
inline uint32_t HttpModifyNameRet::_internal_serverid() const {
  return serverid_;
}
inline uint32_t HttpModifyNameRet::serverid() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpModifyNameRet.serverid)
  return _internal_serverid();
}
inline void HttpModifyNameRet::_internal_set_serverid(uint32_t value) {
  
  serverid_ = value;
}
inline void HttpModifyNameRet::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:XrPb.HttpModifyNameRet.serverid)
}

// string rolename = 4;
inline void HttpModifyNameRet::clear_rolename() {
  rolename_.ClearToEmpty();
}
inline const std::string& HttpModifyNameRet::rolename() const {
  // @@protoc_insertion_point(field_get:XrPb.HttpModifyNameRet.rolename)
  return _internal_rolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpModifyNameRet::set_rolename(ArgT0&& arg0, ArgT... args) {
 
 rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:XrPb.HttpModifyNameRet.rolename)
}
inline std::string* HttpModifyNameRet::mutable_rolename() {
  std::string* _s = _internal_mutable_rolename();
  // @@protoc_insertion_point(field_mutable:XrPb.HttpModifyNameRet.rolename)
  return _s;
}
inline const std::string& HttpModifyNameRet::_internal_rolename() const {
  return rolename_.Get();
}
inline void HttpModifyNameRet::_internal_set_rolename(const std::string& value) {
  
  rolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HttpModifyNameRet::_internal_mutable_rolename() {
  
  return rolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HttpModifyNameRet::release_rolename() {
  // @@protoc_insertion_point(field_release:XrPb.HttpModifyNameRet.rolename)
  return rolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HttpModifyNameRet::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:XrPb.HttpModifyNameRet.rolename)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace XrPb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::XrPb::MsgSvrMod_Http_MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::XrPb::MsgSvrMod_Http_MsgId>() {
  return ::XrPb::MsgSvrMod_Http_MsgId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2fMsgHttp_2eproto
